# PASCAL_DEMO_KEYBOARD
Пример программ на Pascal для работы с клавиатурой на низком уровне (1996, времена MS-DOS и PASCAL...)

			       [1] ВВЕДЕНИЕ.
			       *************
     Что такое современная клавиатура компьютера IBM AT	?
     Прежде чем	начать изучать этот вопрос нам необходимо знать: а что же
     такое компьютер вообще, из	чего он	состоит	?

		   [1.1] Основные компоненты компьютера.
		   =====================================
     Компьютер состоит из 5 основных компонент:
     1)	Системный блок;
     2)	Накопитель на жестком диске;
     3)	Накопитель на гибком диске;
     4)	Дисплей;
     5)	Клавиатура;

     Совокупность этих и некоторых других компонент и образует компьютер
     как таковой. Все компоненты компьютера соединяются	между собой с
     помощью специальных кабелей, представляющих из себя набор проводников
     в специальной изоляции с разъемами	на концах.

     1>	Системный блок - это основная компонента компьютера,
     представляющая из себя совокупность металлического	четырехугольного
     корпуса с электронной начинкой внутри.
     Назначение	системного блока:
	1) Выполняет компьютерные программы;
	2) Является вместилищем	основных электронных плат компьютера и
	нескольких компонент компьютера: это накопитель	на жестком диске,
	накопитель на гибком диске и др. Все компоненты	системного блока
	прикручиваются к нему шурупами и соединяются между собой при
	помощи кабелей;
	3) Содержит блок питания, который обеспечивает электронные платы
	системного блока электрической энергией;
	4) Содержит вентилятор,	который	охлаждает электронную начинку
	системного блока, которая вышла	бы без него из строя от	перегрева;
	5) Содержит несколько миниатюрных индикаторов (лампочек), которые
	отображают значения некоторых характеристик и состояний
	компьютера:
	   - индикатор,	показывающий текущую скорость работы компьютера;
	   - лампочка "Power", свечение	которой	означает, что компьютер
	     включен;
	   - лампочка "Turbo", свечение	которой	означает, что компьютер
	     работает с	максимальной скоростью;
	   - лампочка "H/Disk",	свечение которой означает, что в данный
	     момент происходит работа накопителя на жестком диске;
	6) Содержит несколько органов управления компьютером:
	   - кнопку включения/выключения компьютера: "Power";
	   - кнопку начальной установки	компьютера: "Reset" ("сброс");
	   - кнопку переключения скорости работы компьютера: "Turbo";
	   - замок, при	закрытии которого работа на компьютере невозможна;

     2>	Накопитель на жестком диске - это важная компонента компьютера,
     находящаяся внутри	системного блока.
     Назначение	накопителя на жестком диске:
	1) Позволяет постоянно (даже при отключении питания) хранить
	большое	количество информации, данных и	программ.
	2) Хранит специальную информацию и программы, без которых
	компьютер при включении	работать не будет (так называемую "DOS"	и
	др.);

     3>	Накопитель на гибком диске - это нужная	компонента компьютера,
     находящаяся внутри	системного блока. Накопитель на	гибком диске
     служит для	работы с дискетами и позволяет записывать и считывать
     информацию	с них.
	Дискеты	- это специальные пластины с магнитным покрытием (это
     покрытие подобно покрытию магнитофонных кассет), которые способны
     сохранять записанную на них информацию в течении долгого времени.
     Дискеты позволяют обмениваться информацией	между компьютерами, а
     также хранить резервные копии информации, данных и	программ, которые
     могут понадобиться	для их восстановления на жестком диске (если они
     там уничтожатся или разрушатся);

     4>	Дисплей	- это необходимая компонента компьютера, находящаяся вне
     системного	блока и	представляющая из себя подобие обыкновенного
     телевизора. Назначение дисплея в том, чтобы пользователь компьютера
     мог зрительно с ним общаться и взаимодействовать.

     5>	Клавиатура - это необходимая компонента	компьютера, находящаяся
     вне системного блока и представляющая из себя корпус небольшой высоты
     с электронной начинкой внутри. В клавиатуру вделан	набор клавиш и
     индикаторов (миниатюрных лампочек,	отражающих некоторые режимы работы
     клавиатуры). Назначение клавиатуры	в том, чтобы пользователь
     компьютера	мог с помощью пальцев рук общаться и взаимодействовать с
     ним.

			       * * * * * * *

		  [1.2]	Понятия, без которых не	обойтись.
		  =======================================
     1)	Клавиши	- этим термином	будем обозначать набор клавиш, которые
     вделаны в корпус клавиатуры и представляют	из себя	миниатюрные
     переключатели, замыкающие электронные цепи	при их нажатии и
     размыкающие при их	отпускании.

     2)	Контроллер клавиатуры -	это одна из важнейших микросхем
     электронной начинки клавиатуры, с помощью которой происходит
     "общение" системного блока	с клавиатурой.
     Назначение	контроллера клавиатуры:
     - управляет всей электроникой клавиатуры;
     - передает	системному блоку информацию о фактах нажатий и отжатий
       клавиш;
     - передает	системному блоку информацию о состоянии	электроники
       клавиатуры;
     - принимает и исполняет команды системного	блока;

     3)	Центральный процессор -	это "мозг" компьютера, представляющий из
     себя очень	сложную	и большую по размерам электронную микросхему.
     Центральный процессор предназначен	для управления компьютером и с
     помощью него системный блок выполняет компьютерные	программы.

     4)	Оперативная память - это необходимая компонента	компьютера,
     которая предназначена для хранения	данных и программ во время работы
     компьютера. Без оперативной памяти	компьютер работать не может. После
     выключения	питания	компьютера все данные из оперативной памяти
     стираются.

     5)	Буфер клавиатуры - это небольшая оперативная память, находящаяся
     в электронике клавиатуры. В этой памяти храниться информация о тех
     фактах нажатий и отжатий клавиш, которые были, но еще не переданы в
     системный блок. Буфер клавиатуры состоит из 15 ячеек, каждая из
     которых может содержать число от 0	до 255.

     6)	Системный буфер	клавиатуры (СБК) - это часть оперативной памяти
     системного	блока, в которой хранятся данные, которые получены путем
     анализа той информации (о фактах нажатий и	отжатий	клавиш)	буфера
     клавиатуры, которую системный блок	получил	от клавиатуры (а именно	от
     контроллера клавиатуры). Системный	буфер клавиатуры состоит из 16
     ячеек, каждая из которых может содержать два числа, каждое	из которых
     может принимать значения от 0 до 255.

     7)	BIOS - это набор специальных программ, постоянно хранящихся в
     памяти компьютера (системного блока), которые после выключения
     питания не	стираются. Эти программы непосредственно управляют
     электроникой компьютера и без этих	программ компьютер работать не
     может. Использование возможностей этих программ делает
     программирование более простым и быстрым.

     8)	Порты ввода/вывода информации -	это специальные	микросхемы,
     которые соединяют электронику различных компонент компьютера
     (например дисплея и системного блока) между собой.	Порты являются как
     бы	"воротами" компьютера, через которые проходят потоки различной
     информации. Каждый	порт имеет свой	индивидуальный номер, с	помощью
     которого мы можем узнать и	изменить все те	потоки информации, которые
     через него	проходят. Необходимо заметить, что и клавиатура
     взаимодействует с компьютером (системным блоком) тоже через порты
     ввода/вывода информации.

     9)	Прерывание - это процесс, состоящий из трех основных этапов:
	 1) Компьютер запоминает свое текущее состояние	(чтобы после в
	 него вернуться) и прекращает свою текущую работу;
	 2) Начинает выполняться одна из специальных программ, которая
	 определяется номером прерывания (каждое прерывание имеет свой
	 индивидуальный	номер);
	 3) После выполнения специальной программы, выполняющей
	 (обслуживающей) данное	прерывание, компьютер восстанавливает свое
	 предыдущее состояние (которое было предварительно запомнено), и
	 начинает продолжать свою предыдущую работу с того места, где
	 прежде	он остановился;

			       - - - - - - -

     При обозначении цифр будем	использовать следующее правило:	если после
     цифры стоит буква 'd' или ничего не стоит,	то цифра написана в
     десятичной	системе	исчисления, а если после цифры стоит буква 'h',	то
     цифра написана в шестнадцатеричной	системе.

			       - - - - - - -

		Теперь перейдем	к знакомству с клавиатурой.

			       * * * * * * *

		       [2] ЗНАКОМСТВО С	КЛАВИАТУРОЙ.
		       *****************************
     Клавиатура	-  это устройство для ввода информации в компьютер с
     помощью пальцев рук. Клавиатура состоит из	набора клавиш (с помощью
     которых, собственно, и осуществляется ввод	информации) и электроники,
     которая их	обслуживает. Главной частью клавиатурной электроники
     является контроллер клавиатуры, связывающий системный блок	компьютера
     с остальной электроникой клавиатуры.

     Все клавиши клавиатуры можно разделить на 3 группы:
	1) Символьные -	служат для ввода компьютерных символов:	букв,цифр,
	знаков препинания и других символов (например: "% / # - + = *");
	2) Функциональные - служат для выполнения определенных действий,
	например для удаления неверно введенного символа, для перемещения
	изображения по экрану и	др.;
	3) Клавиши-переключатели - изменяют режим работы клавиатуры и
	назначение некоторых клавиш (например включают или выключают режим
	ввода прописных	букв и т.д.);

     В правой части клавиатуры находятся 17 клавиш, которые имеют свои
     аналоги в основной	части клавиатуры (например в клавиатуре	имеются
     две клавиши "Стрелка вправо", две клавиши "Enter" и т.д.).	Зачем,
     спрашивается, нужно несколько одинаковых по назначению клавиш ?
     Хотя это и	излишество, но оно очень удобно	при работе с клавиатурой
     и поэтому клавиатуру мысленно разделяют на	две части: основную и
     дополнительную. Если говорят о клавишах дополнительной клавиатуры,
     то	имеют в	виду именно 17 клавиш в	правой части клавиатуры, а если
     говорят просто о клавишах,	то имеют ввиду любые клавиши клавиатуры.

     Для понимания работы клавиатуры очень важно знать сущность	следующих
     понятий:
	1) Скэн-код клавиши - это условный номер, которые присвоен данной
	клавише	клавиатуры, т.о. каждая	клавиша	клавиатуры имеет свой
	индивидуальный номер, называемый скэн-кодом.Современная	клавиатура
	имеет 101 клавишу, а значит и 101 скэн-код (сейчас, правда,
	появились некоторые заморские клавиатуры с 102 клавишами, но эти
	клавиатуры редки и касаться их мы не будем). Скэн-коды имеют
	номера от 1 до 101.
	2) Компьютер имеет определенный	набор компьютерных символов. Эти
	символы	подразделяются на буквы	(русские и латинские), знаки
	препинания (например: ",?!") и специальные символы (например:
	"*/-+()%#$&"). Всего в компьютере имеется 256 различных	символов.
	Каждый компьютерный символ имеет свой определенный порядковый
	номер, который представляет из себя число в диапазоне от 0 до 255.
	Таким образом, первый компьютерный символ имеет	0 порядковый
	номер, второй символ - 1, 256 символ - 255 порядковый номер.
	Порядковый номер компьютерного символа называют	либо ASCII
	кодом, либо расширенным	ASCII кодам. Таким образом, например,
	порядковый номер символа "R", равный 82, мы можем назвать либо
	ASCII кодом, либо расширенными ASCII кодом. Зачем, спрашивается,
	нужно два различных названия для одного	и того же порядкового
	номера символа ? Дело в	том, что когда мы нажимаем на к-либо
	клавишу	клавиатуры, компьютер ставит ей	в соответствие к-либо
	определенный символ. Например, если нажимается клавиша с
	изображенным на	ней символом "?", то компьютер поставит	ей в
	соответствие символ "?". Но если мы нажмем на клавишу "F5", то
	компьютер и ей поставит	в соответствие символ "?". Но как же нам
	в таком	случае узнать, какая именно нажималась клавиша при вводе
	символа	"?": клавиша "F5" или клавиша с	изображенным на	ней
	символом "?" ? Ответ прост: когда мы нажимаем на клавишу с
	изображенным на	ней символом "?", то компьютер ставит ей в
	соответствие символ "?", порядковый номер которого (63)	он назовет
	ASCII кодом, а когда мы	нажимаем на клавишу "F5", то компьютер
	поставит и ей в	соответствие тот же символ "?",	но его порядковый
	номер он назовет расширенным ASCII кодом. Поэтому стоит	нам только
	узнать,	как называется порядковый номер	введенного с клавиатуры
	символа, и мы сразу однозначно определим ту клавишу, которую
	нажимали при вводе данного символа. Как	узнать название
	порядкового номера компьютерного символа мы узнаем позже.

     Высказывание "символ с ASCII кодом" равнозначно высказыванию
     "порядковый номер символа называется ASCII кодом".	Высказывание
     "символ с расширенным ASCII кодом"	равнозначно высказыванию
     "порядковый номер символа называется расширенный ASCII кодом".

     Таким образом:
     - каждая клавиша имеет свой индивидуальный	скэн-код;
     - при нажатии к-либо клавиши клавиатуры компьютер (системный блок)
       ставит ей в соответствие	определенный символ либо с ASCII кодом,
       либо с расширенным ASCII	кодом;

     Каждая клавиша клавиатуры имеет свое назначение по	умолчанию, и это
     назначение	легко может измениться компьютерной программой,	т.е.
     программным путем.

     1>	Назначение по умолчанию	символьных клавиш состоит в том,чтобы с	их
     помощью вводить различные символы.

     2>	Назначение по умолчанию	функциональных клавиш :
     --------------------------------------------------

     Клавиша:	       Назначение:
     --------	      -----------
     Esc	       Служит для отмены к-либо	действий в программе
		       (например для завершения	работы программы).

     F1,F2,...,F12     Специальные клавиши, назначение которых
		       определяется работающей программой.

     PrintScreen       При нажатии на эту клавишу содержимое экрана
		       распечатывается на принтере.

     Pause	       При нажатии на эту клавишу работа компьютера
		       приостанавливается до нажатия к-либо другой
		       клавиши.

     Home	       Перемещает курсор в начало строки на экране.

     End	       Перемещает курсор в конец строки	на экране.

     PgUp (PageUp)     Перемещает текст	на экране вверх	на 25 строк.

     PgDn (PageDown)   Перемещает текст	на экране вниз на 25 строк.

     Del (Delete)      Эта клавиша стирает тот символ на экране, на
		       котором находится курсор. Курсор	- это специальный
		       значок на экране, показывающий то место экрана, на
		       которое будет выводится очередной символ, вводимый
		       с клавиатуры.

     BackSpace	       Эта клавиша стирает тот символ на экране, который
		       находится левее курсора.

     Стрелки	       Служат для перемещения курсора по экрану	(вверх,
		       вниз, влево, вправо).

     Enter	       Этой клавишей завершают ввод строк с клавиатуры.
		       При ее нажатии считается, что вводимая строка
		       уже набрана.

     Tab	       Перемещает курсор немного вправо	по экрану.

     3>	Назначение по умолчанию	клавиш-переключателей :
     --------------------------------------------------

     Клавиша:	      Назначение:
     --------	       -----------
     CapsLock	       Включает/выключает режим	ввода прописных	букв. Если
		       установлен режим	прописных букв,	то вводимые буквы
		       будут иметь прописной вид, например: "А Б В". Если
		       режим прописных букв выключен, то вводимые буквы
		       будут иметь строчный вид, например: "а б в".

     NumLock	       Данной клавишей определяет, как будут
		       использоваться клавиши дополнительной клавиатуры:
		       - как цифры (для	ввода цифр);
		       - как клавиши управления	курсором (для перемещения
			 текста	и курсора по экрану);

     ScrollLock	       Включает/выключает режим, при котором нажатия на
		       стрелки будут вызывать перемещение не курсора по
		       экрану, а изображения (например текста или рисунка)
		       на нем.

     Ins (Insert)      Переключает режим вставки/замены	символов.
		       Разберем	отличие	этих режимов на	следующем примере:
		       пусть на	экране имеется строка "Комютер", а курсор
		       находится на букве "ю"; Теперь нажмем на	клавиатуре
		       на букву	"п" и после нее	на букву "ь".
		       Что же получится	на экране ?
		       - если режим вставки, то: "Компьютер".
		       - если режим замены, то:	"Компьер".

     Shift	       Если нажать на эту клавишу и не отпуская	ее нажать
		       на к-либо букву,	то
		       - если установлен режим прописных букв (клавишей
			 "CapsLock"), то буква введется	в строчной форме.
		       - если установлен режим строчных	букв (клавишей
			 "CapsLock"), то буква введется	в прописной форме.
		       Таким образом эта клавиша временно (пока	она
		       нажата) изменяет	тот режим ввода	(прописных или
		       строчных	букв), который установлен клавишей
		       "CapsLock".

     Ctrl,Alt	       Если нажать на одну из этих клавиш и не отпуская
		       ее нажать на к-либо другую, то назначение второй
		       нажатой клавиши изменится. Например, если мы просто
		       нажмем на клавишу "Pause", то результат будет
		       такой: работа компьютера	приостановится до нажатия
		       к-либо другой клавиши, а	если мы	сперва нажмем на
		       клавишу "Ctrl" и	не отпуская ее нажмем на клавишу
		       "Pause",	то результат будет совсем другой:
		       программа, которая в данный момент работает,
		       завершит	свою работу.

			       * * * * * * *

	    [3]	МЕХАНИЗМ ВЗАИМОДЕЙСТВИЯ	КЛАВИАТУРЫ И КОМПЬЮТЕРА.
	    ****************************************************

     ┌──────────┬────────┬──┐		   ┌─────────────────────────────┐
     ├─┐	│Буфер к.│  │		   │	  ┌───────────────┐	 │
     │К│	└────╥───┘  │		   │	  │    B I O S	  │	 │
     │л│ ╔════╗	 ┌───╨───┐  │		   │   ┌──┼───────────────┤	 │
     │а│ ║Элек║	 │ Intel │  │		   │   │П │ Центральный	  │	 │
     │в├─╢трон╟──┤8 0 4	2│  │ К	а б е л	ь  │   │о │ Процессор	  │	 │
     │и├─╢ика ╟──┤Контрол╞══╪<════════════>╪═══╡р ├───────────────┤	 │
     │ш├─╫─┬┬─╫──┤лер кла│  │		   │   │т │ Оперативная	  ├────┐ │
     │и│ ╟─┼┼─╢	 │виатуры│  │		   │   │ы │ Память	  │СБК │ │
     ├─┘ ╚═╧╧═╝	 └───────┘  │		   │   └──┴───────────────┴────┘ │
     │	К л а в	и а т у	р а │		   │ С и с т е м н ы й	 б л о к │
     └──────────────────────┘		   └─────────────────────────────┘

				  Рис. 1.

     При рассмотрения механизма	взаимодействия клавиатуры и компьютера
     используйте рис.1.	Итак:

     1)	Если системный блок разрешил клавиатуре	анализировать факты
     нажатий и отпусканий клавиш, то переход на	шаг 2, иначе на	шаг 1;
     2)	Если в буфере клавиатуры есть свободное	место, то переход на
     шаг 3, иначе на шаг 5;
     3)	Ожидается факт нажатия или отпускания к-либо клавиши;
     4)	Информация о факте нажатия или отпускания клавиши помещается в
     буфер клавиатуры;
     5)	Информация о самом раннем факте	нажатия	или отпускания клавиши
     помещается	из буфера клавиатуры в порт 60h;
     6)	Если системный блок разрешил клавиатуре	запрашивать прерывание №9,
     то	контроллер клавиатуры запрашивает разрешение у системного блока
     на	прерывание №9 (клавиатурное прерывание), иначе переход на шаг 1;
     7)	Если системный блок не реагирует на запрос клавиатуры, то переход
     на	шаг 1;
     8)	Клавиатура перестает анализировать факты нажатий и отпусканий
     клавиш. Начинается	обслуживание прерывания	№9, т.е. начинает
     выполняется одна из специальных программ BIOSа, которая выполняет
     следующие действия:
       8.1) Считывает информацию из порта 60h;
       8.2) Сообщает контроллеру клавиатуры о считывании данного с
       порта 60h. Этим действием системный блок	заставляет контроллер
       клавиатуры удалить из буфера клавиатуры информацию, только что
       считанную системным блоком из порта 60h,	а также	разрешает ему
       анализировать факты нажатий и отпусканий	клавиш.
       8.3) Если считанная информация соответствует клавише-переключателю,
       то зарегистрировать этот	факт в ОЗУ по адресам 417h и 418h.
       Если считанная информация соответствует нажатию клавише "Ins(ert)",
       то переход на шаг 8.6, иначе переход на шаг 1;
       8.4) Если в системном буфере клавиатуры есть свободное место, то
       переход на шаг 8.5, иначе издается звуковой сигнал и делается
       переход на шаг 1;
       8.5) Если нажатой клавише принято ставить в соответствие	символ
       с ASCII кодом, то поместить в системный буфер клавиатуры	порядковый
       номер соответствующего символа и	скэн-код нажатой клавиши. Переход
       на шаг 1;
       8.6) Если нажатой клавише принято ставить в соответствие	символ с
       расширенным ASCII кодом,	то поместить в системный буфер клавиатуры
       число ноль (это является	признаком того,	что нажатой клавише
       ставится	в соответствие символ с	расширенный ASCII кодом) и
       порядковый номер	соответствующего символа;


			      [3.1] Пояснения.
			     ================
     1>	Системный блок может запретить клавиатуре реагировать на любые
     факты нажатий и отпусканий	клавиш на клавиатуре. Для этой цели
     системный блок посылает в контроллер клавиатуры специальную команду,
     которая запретит электронным схемам клавиатуры реагировать	на к-либо
     факты нажатия или отпускания клавиш. Другой командой системный блок
     может разрешить клавиатуре	реагировать на факты нажатий или
     отпусканий	клавиш.	Надо отметить, что системный блок посылает команды
     клавиатуре	и считывает из нее информацию через специальные	порты
     ввода/вывода информации, номера которых 60h и 64h.

	Если системный блок запретил клавиатуре	реагировать на факты
     нажатий и отпусканий клавиш, то ввод с клавиатуры невозможен, причем
     до	тех пор, пока системный	блок не	разрешит клавиатуре реагировать	на
     факты нажатий и отпусканий	клавиш.

	Итак предположим, что системный	блок разрешил клавиатуре
     реагировать на факты нажатий и отпусканий клавиш, тогда:

     2>	Контроллер клавиатуры проверяет: есть ли свободное место в его
     буфере клавиатуры ?
			       - - - - - - -

	Буфер клавиатуры изображен на рис. 2. Буфер клавиатуры можно
     представить как таблицу из	15 ячеек (элементов), каждая ячейка
     которого может содержать к-либо число от 0	до 255.	Все ячейки
     буфера клавиатуры пронумерованы от	1 до 15. Кроме 15 ячеек	в
     буфере клавиатуры имеются еще 2 специальные ячейки: это так
     называемые	ячейка "хвоста"	и ячейка "головы". Каждая из этих ячеек
     содержит к-либо число от 1	до 15, которое соответствует к-либо
     ячейки буфера клавиатуры. Например, если в	ячейке "головы"	находится
     число 02, то это число соответствует ячейке №2. Что значит	фраза
     "соответствует ячейке" ? Это станет ясно чуть позже ...
	Предположим, что мы только что включили	компьютер. Тогда буфер
     клавиатуры	будет полностью	пустой (а это значит, что в нем	есть
     свободное место), в его ячейках будут содержаться нули, а в ячейке
     "головы" и	в ячейке "хвоста" будет	находится число	1.

		       Устройство буфера клавиатуры.
		       .............................

	    ┌────────────┐		  ┌───────────────────┐
	    │ Ячейка №1	 │		  │ Ячейка "головы"   │
     З	│   ├────────────┤		  │ буфера клавиатуры │
     а	│   │ Ячейка №2	 │<─────────────┐ ├───────────────────┤
     п	│   ├────────────┤		└─┤	   02	      │
     о	│   .		 .		  └───────────────────┘
     л	│   ├────────────┤
     н	│   │ Ячейка №7	 │<─────┐	  ┌───────────────────┐
     е	│   ├────────────┤	│	  │ Ячейка "хвоста"   │
     н	│   .		 .	│	  │ буфера клавиатуры │
     и	√   ├────────────┤	│	  ├───────────────────┤
     е	    │ Ячейка №15 │	└─────────┤	   07	      │
	    └────────────┘		  └───────────────────┘

				  Рис. 2

			       - - - - - - -
     3>	Если в буфер клавиатуры	имеется	свободное место, то контроллер
     клавиатуры	ожидает	факта нажатия или отпускания к-либо клавиши
     (т.е. ждет	пока мы	не нажмем на к-нибудь клавишу),а если нет места	-
     то	делается переход на шаг	5.


     4>	Итак, контроллер клавиатуры дождался, наконец, пока мы нажмем и
     отпустим к-либо клавишу.

			       - - - - - - -
	Надо заметить, что клавиатуре совершенно безразлично, что
     изображенно на нажатой клавише: буква ли, цифра или что-то	другое.
     Дело в том, что клавиатура	знает только порядковый	номер нажатой или
     отпущенной	клавиши	и этот номер называется	скэн-кодом клавиши, а что
     изображенно на клавише, и что это изображение означает - она
     совершенно	не знает. Как же тогда,	если например Вы нажмете на
     клавишу с изображением "*", компьютер (системный блок) узнает, что	Вы
     ввели именно "*", а не что-то другое? А просто: ведь системный блок
     знает,какой символ	какому скэн-коду соответствует.	Поэтому, системный
     блок однозначно (по скэн-коду клавиши) определяет,	какой символ Вы
     ввели. Таким образом: задачей определения,	что же за символ,
     собственно, вводился с клавиатуры,	занимается не клавиатура, а
     системный блок. Клавиатура	лишь сообщает системному блоку порядковые
     номера (скэн-коды)	нажимаемых и отпускаемых клавиш.
			       - - - - - - -

	Так-как	мы предположили, что буфер клавиатуры полностью	весь
     пустой (так-как компьютер только что включили), то	контроллер
     клавиатуры	запишет	в его ячейку №1	скэн-код только	что нажатой на
     клавиатуре	клавиши. После этого контроллер	клавиатуры запишет в
     ячейку "хвоста" число 02. Это означает, что следующая свободная
     ячейка буфера клавиатуры имеет номер, равный 2 (т.е. ячейка №2). В
     ячейке "головы" все еще остается число 01.	Это означает, что ячейка,
     которая была заполнена первой, имеет номер, равный	1(т.е. ячейка №1).

	Теперь надо учесть тот факт, что только	что нажатая клавиша еще
     ведь была и отжата! Да, для контроллера клавиатуры	этот факт
     знаменателен, и поэтому следующим делом, которое он сделает, будет
     помещение в следующую свободную ячейку, номер которой хранится в
     ячейке "хвоста", числа, которое на	128 больше скэн-кода нажатой
     клавиши. После этого он запишет в ячейку "хвоста" число 03. Это
     означает, что следующая свободная ячейка буфера клавиатуры	уже имеет
     номер, равный 3 (т.е. ячейка №3).В	ячейке "головы"	все еще	остается
     число 01. Это означает, что ячейка, которая была заполнена	первой,
     имеет номер, равный 1 (т.е. ячейка	№1). Таким образом, если в ячейке
     буфера клавиатуры находится число большее 128, то это говорит о том,
     что какая-то клавиша была отжата, а если в	ячейке буфера клавиатуры
     находится число меньшее либо равное 128, то это говорит о том, что
     какая-то клавиша была в нажатом состоянии.	Таким образом, контроллер
     клавиатуры	учитывает все факты и нажатия и	отпускания клавиш.

			       - - - - - - -
	А что будет, если мы нажмем к-либо клавишу и будем ее удерживать ?
     В этом случае контроллер клавиатуры будет записывать в свой буфер
     клавиатуры	скэн-коды нажатой клавиши до тех пор, пока нажатая клавиша
     не	будет отжата. Это явление называется "автоповтор". Как только
     нажатая клавиша будет отжата контроллер клавиатуры	запишет	в
     следующую свободную ячейку	(на которую указывает ячейка "хвоста")
     скэн-код отжатой клавиши +	128. Таким образом, если в ячейках буфера
     клавиатуры	в подряд записан один и	тот же скэн-код	клавиши, то это
     говорит о том, что	к-либо клавиша была нажата долгое время.

	А что будет, если мы нажмем к-либо клавишу и не	отпуская ее нажмем
     на	к-либо другую клавишу, после чего отпустим вторую нажатую клавишу
     а вслед за	ней и первую ? В этом случае будет следующее:
     - в буфер клавиатуры будет	записываться скэн-код первой нажатой
       клавиши до тех пор, пока	не нажмется вторая клавиша;
     - как только нажмется вторая клавиша в буфер клавиатуры сразу начнет
       записываться скэн-код второй нажатой клавиши, до	тех пор, пока не
       она не отожмется;
     - как только отожмется вторая нажатая клавиша в буфер клавиатуры
       сразу запишется скэн-код	второй клавиши + 128, после чего в буфер
       клавиатуры ничего не будет записываться до тех пор, пока	не
       отожмется первая	нажатая	клавиша;
     - как только отожмется первая нажатая клавиша в буфер клавиатуры
       сразу запишется ее скэн-код + 128;

	Кроме того, есть некоторые комбинации из нажатых вместе	клавиш,
     которые имеют свой	индивидуальный скэн-код, который занимает (!!)
     несколько ячеек в буфере клавиатуры, т.е. такое совместное	нажатие
     нескольких	клавиш как бы эквивалентно нажатию какой-то "невидимой"
     всем нам клавиши с	длинющим скэн-кодом. При отжатии такой комбинации
     клавиш в буфер клавиатуры заносится ни скэн-код + 128, а нечто
     другое, причем оно	тоже занимает несколько	ячеек буфера клавиатуры.
     Мы	не будем рассматривать подобные	комбинации ("сверх" клавиши), т.к.
     они не представляющие для нас особого интереса ...

	Теперь рассмотрим ситуацию, когда в буфере клавиатуры заполненно
     14	ячеек, скажем с	ячейки №1 по ячейку №14	(ячейка	№15 еще	свободна):

	    ┌────────────┐		  ┌───────────────────┐
	    │ Ячейка №1	 │<─────────────┐ │ Ячейка "головы"   │
	    ├────────────┤		│ │ буфера клавиатуры │
	    │ Ячейка №2	 │		│ ├───────────────────┤
	    ├────────────┤		└─┤	   01	      │
	    .		 .		  └───────────────────┘
	    ├────────────┤
	    │ Ячейка №14 │		  ┌───────────────────┐
	    ├────────────┤		  │ Ячейка "хвоста"   │
	    │ Ячейка №15 │<─────────────┐ │ буфера клавиатуры │
	    └────────────┘		│ ├───────────────────┤
					└─┤	   15	      │
					  └───────────────────┘

     В этом случае контроллер клавиатуры определит, что	в его буфере
     осталась всего лишь одна свободная	ячейка (№15) и он запишет в нее
     число 0, причем ничего другого в нее записать будет уже нельзя (!!).
     Таким образом, данные о фактах нажатий и отжатий клавиш размещаются
     не	во всех	15 ячейках буфера клавиатуры, а	в каких-либо 14	ячейках,
     причем в последней	из свободных ячеек (15-ой) всегда будет	записан	0
     (это дело рук контроллера клавиатуры). Зачем же надо было контроллеру
     клавиатуры	записывать в последнюю из свободных ячеек число	0 ? Прежде
     чем ответить на этот вопрос рассмотрим следующую ситуацию:

	    ┌────────────┐		  ┌───────────────────┐
	    │ Ячейка №1	 │<─────┐	  │ Ячейка "головы"   │
	    ├────────────┤	│	  │ буфера клавиатуры │
	    .		 .	│	  ├───────────────────┤
	    ├────────────┤	│	┌─┤	   11	      │
	    │ Ячейка №11 │<─────│───────┘ └───────────────────┘
	    ├────────────┤	│
	    │ Ячейка №12 │	│	  ┌───────────────────┐
	    ├────────────┤	│	  │ Ячейка "хвоста"   │
	    .		 .	│	  │ буфера клавиатуры │
	    ├────────────┤	│	  ├───────────────────┤
	    │ Ячейка №15 │	└─────────┤	   01	      │
	    └────────────┘		  └───────────────────┘

     Смысл данной ситуации таков: в то время, когда буфер клавиатуры был
     полностью весь пустой, по каким-то	причинам ячейка	"головы" и ячейка
     "хвоста" указывали	не на 1	ячейку,	а на 11	ячейку буфера клавиатуры.
     После этого были заполнены	5 ячеек	(т.е. ячейки с 11 по 15). Что же
     будет делать контроллер клавиатуры, когда ему будет нужно записать
     к-либо информацию в буфер клавиатуры, ведь	хоть в нем и заполнилась
     последняя 15 ячейка, но ведь имеется еще 9	свободных ячеек	(т.е.
     ячейки с 1	по 10) ? Итак: после того, как заполнится 14 ячейка,
     контроллер	клавиатуры запишет в ячейку "хвоста" число 15; после того,
     как заполнится 15 ячейка он запишет в ячейку "хвоста" число 1, и уже
     после этого он сможет заполнить ячейку №1 (после ее заполнения в
     ячейку "хвоста" он	запишет	число 2), и т.д. до тех	пор, пока он не
     заполнит ячейку №9. После заполнения ячейки №9 значение ячейки
     "хвоста" будет равно 10,а значение	ячейки "головы"	останется прежним,
     т.е. равным 11.Теперь контроллер клавиатуры сделает вывод:	раз ячейки
     "головы" и	"хвоста" отличаются на 1, то можно считать, что	свободного
     места в буфере клавиатуры уже нет,	и поэтому он запишет в последнюю
     свободную ячейку (т.е. ячейку №10)	число 0.

	Теперь пункт 3 (ожидание факта нажатия или отпускания клавиши)
     выполняться не будет, т.к.	уже некуда поместить информацию	о к-либо
     факте нажатия или отпускания клавиши.

	Теперь подошло время ответить на вопрос: зачем же надо было
     контроллеру клавиатуры записывать в последнюю из свободных	ячеек
     число 0 ?	Предположим что	после заполнения 9 ячейки контроллер
     клавиатуры	записал	в ячейку "хвоста" число	10, после этого	он
     заполнил данными ячейку №10 и записал в ячейку "хвоста" число 11.
     И что бы получилось ? А то, что значения ячеек "хвоста" и "головы"
     содержали бы число	11, как	и в случае полностью пустого буфера
     клавиатуры. А как бы мы (да и компьютер) теперь узнали: буфер
     клавиатуры	весь пуст и забит разными числами ("мусором"), или он
     весь полон	и содержит информацию о	фактах нажатий и отжатий клавиш	?
     К сожалению мы этого никак	бы не определили! Именно поэтому и сделали
     буфер клавиатуры таким хитрым:
     - если значения ячеек "хвоста" и "головы" равны, то это означает, что
       буфер весь пуст;
     - если значение ячейки "головы" больше значения ячейки "хвоста" на	1,
       причем ячейка "хвоста" будет указывать на ячейку	с записанным в нее
       нулем, то это означает, что буфер весь полон;

	Таким образом, контроллер клавиатуры записывает	в последнюю из
     свободных ячеек число 0 лишь для того, чтобы в ней	что-нибудь было,
     т.к. в эту	ячейку все ровно нельзя	ничего записать	(этого требует
     хитрость устройства буфера	клавиатуры).
			       - - - - - - -

     5>	После того, как	контроллер клавиатуры записал в	свободную ячейку
     (на которую указывала ячейка "хвоста") буфера клавиатуры скэн-код
     нажатой клавиши или скэн-код + 128	(если клавиша была отжата), то
     он	делает следующее: он ищет в буфере клавиатуры ту ячейку, в
     которую он	записал	информацию раньше всего	(этим самым он
     вспоминает	о самом	раннем факте нажатия или отпускания клавиши,
     который он	запомнил). А это как раз та ячейка, на которую указывает
     ячейка "головы" (т.е. в ячейке "головы" хранится номер ячейки с
     информацией о самом раннем	факте нажатия или отпускания клавиши).
     После того, как нужная ячейка будет найдена, ее значение (т.е. то,
     что в ней хранится) помещается в порт №60h. Помещение содержимого
     этой ячейки в порт	№60h можно представить так: содержимое ячейки
     помещается	в чудесную "шкатулку" с	надписью "порт 60h", из	которой,
     после, системный блок будет "доставать" ее	содержимое, т.е. данные,
     которые желает ему	сообщить клавиатура.

			       - - - - - - -
	После того, как	системный блок "достанет" данное клавиатуры из
     порта 60h,	он даст	знать об этом контроллеру клавиатуры, который
     узнав об этом обрадуется (т.к. его	данное успешно считано системным
     блоком) и изменит значение	ячейки "головы", а именно: если	в
     ячейке "головы" было число	1, то будет 2, если было 3, то будет 4
     (этим самым контроллер клавиатуры удаляет из своего буфера	клавиатуры
     то	данное,	которое	только что считал системный блок). Таким образом,
     значение ячейки "головы" снова будет указывать на ту ячейку буфера
     клавиатуры, в которой хранится наистарейшая, еще не считанная
     системным блоком информация о факте нажатия или отпускания	клавиши.
     Если после	этого:
     - значения	ячеек "хвоста" и "головы" равны, то это	означает, что
       буфер весь пуст;
     - значение	ячейки "головы"	больше значения	ячейки "хвоста"	на 1,
       причем ячейка "хвоста" будет указывать на ячейку	с записанным в нее
       нулем, то это означает, что буфер весь полон;
			       - - - - - - -

	Итак, данные из	ячейки с информацией о самом раннем факте нажатия
     или отпускания клавиши помещены в порт №60h.

     6>	Если системный блок разрешил клавиатуре	запрашивать прерывание №9,
     то	контроллер клавиатуры запрашивает разрешение у системного блока
     на	прерывание №9 (посылает	по кабелю в системный блок специальный
     сигнал, который просит его	выполнить прерывание №9), иначе	переход
     на	шаг 1;
			       - - - - - - -

     Системный блок может запретить клавиатуре запрашивать прерывание №9.
     Для этой цели системный блок посылает в контроллер	клавиатуры
     специальную команду, которая запретит контроллеру клавиатуры
     запрашивать прерывание №9.	Другой командой	системный блок может
     разрешить контроллеру клавиатуры запрашивать прерывание №9.

			       - - - - - - -
	Что же такое "прерывание №9" ? Прерывание №9 - это процесс,
     состоящий из трех основных	этапов:
     1)	Системный блок запоминает свое текущее состояние (чтобы	после в
     него вернуться) и прекращает свою текущую работу;
     2)	Начинает выполняться одна из специальных программ BIOSа, которая
     называется	"обработчик прерывания №9". Эта	программа считывает данное
     клавиатуры	через порт 60h и решает	(на основании полученного от
     клавиатуры	скэн-кода или скэн-кода	+ 128),	что же за символ был
     введен с клавиатуры, после	чего записывает	в системный буфер
     клавиатуры	соответствующие	данные;
     3)	После того, как	обработчик прерывания №9 закончит свою работу,
     системный блок восстановит	свое предыдущее	состояние (которое было
     предварительно запомнено),	и начинает продолжать свою предыдущую
     работу с того места, где прежде он	остановился;
			       - - - - - - -

	Итак предположим, что системный	блок разрешил клавиатуре
     запрашивать прерывание №9.

     7>	Если системный блок по каким-то	причинам занят и не может уделить
     клавиатуре	время на выполнение прерывания №9, то переход на шаг 1.

     8>	Системный блок получил сигнал из клавиатуры, просящий его
     выполнить прерывание №9. Он запоминает свое текущее состояние, чтобы
     после в  него вернуться, и	перестает реагировать на клавиатуру (т.е.
     на	ее просьбы выполнить прерывание	№9).

	После того, как	системный блок закончит	выполнять прерывание №9
     и будет хотеть перейти на шаг №1, системный блок снова начнет
     реагировать на клавиатуру и ее просьбы выполнить прерывание №9,
     восстановит свое предыдущее состояние (он ранее его запомнил) и
     начнет продолжать то дело,	которым	он занимался до	выполнения
     прерывания.

	Теперь компьютер запустит специальную программу	BIOSа -	обработчик
     прерывания	№9 (эта	программа постоянно хранится в памяти системного
     блока), которая будет выполнять прерывание	№9.

	Таким образом, когда клавиатура	узнает о каком-либо факте ввода
     с клавиатуры, у нее сразу появляется желание сообщить об этом
     системному	блоку, чтобы он	с помощью своей	программы (обрабатывающей
     прерывание	№9) разобрался:	что же такое введенно с	клавиатуры и что
     это значит: символ, буква и т.д.. Дело в том, что клавиатура никаких
     символов не знает (она вообще кроме порядковых номеров клавиш мало
     что знает). Поэтому системный блок	взвалил	на себя	такую обязанность:
     принимать от клавиатуры скэн-код нажатой клавиши или скэн-код+128 -
     если клавиша отжалась и понимать: что же за символ	был введен с
     клавиатуры, прописной он должен иметь вид или строчный и т.д.

			       - - - - - - -
	Интересно, а как же системный системный	блок узнает, какой вид
     должен иметь введенный символ, прописной или строчный ? Все просто:
     если, к примеру, мы нажмем	впервые	на клавишу "CapsLock" (она
     устанавливает и выключает режим ввода букв	в прописном виде), то
     системный блок запомнит этот факт (сразу после того, как примет от
     клавиатуры	скэн-код клавиши "CapsLock") и после получения от
     клавиатуры	к-либо скэн-кода символьной клавиши будет считать, что
     символ, соответствующий этой клавиши, имеет прописной вид.	Если
     же	после системный	блок снова получит от клавиатуры скэн-код,
     соответствующий клавиши "CapsLock", то он запомнит	этот факт и после
     получения от клавиатуры к-либо скэн-кода символьной клавиши будет
     считать, что символ, соответствующий этой клавиши,	имеет строчный
     вид.
			       - - - - - - -

     Итак, программа BIOSа, которая служит для выполнения прерывания №9,
     начинает свою работу, а именно:

	8.1> Считывает данное клавиатуры из порта 60h и	запоминает его
	(где она запоминает это	данное нам не важно);

	8.2> Сообщает контроллеру клавиатуры о считывании данного с
	порта 60h. Этим	действием системный блок заставляет контроллер
	клавиатуры удалить из буфера клавиатуры	информацию, только что
	считанную системным блоком из порта 60h, а также разрешает ему
	анализировать факты нажатий и отпусканий клавиш. А как удаляется
	информация из буфера клавиатуры	? А очень просто: значение ячейки
	"головы" увеличивается на 1, и это означает, что свободных ячеек
	в буфере клавиатуры стало больше на 1. Таким образом:
	- ячейка "хвоста" буфера клавиатуры изменяется при записи данного
	  в его	свободную ячейку, и это	означает, что свободного места в
	  буфере клавиатуры стало меньше (на 1 ячейку);
	- ячейка "головы" буфера клавиатуры изменяется при считывании
	  системным блоком данного с его заполненной ячейки, и это
	  означает, что	свободного места в буфере клавиатуры стало больше
	  (на 1	ячейку);

	8.3> Если считанное данное из порта №60h соответствует нажатию или
	отжатию	к-либо клавиши-переключателю, то в ОЗУ по адресам 417h и
	418h зарегистрируется этот факт	(в этих	ячейках	памяти
	регистрируются факты нажатия и отжатия клавиш-переключателей),
	причем если считанное данное больше 128	(это означает, что к-либо
	клавиша-переключатель была отжата), то зарегистрировать	факт
	отжатия, а если	считанное данное меньше	или равно 128, то
	зарегистрировать факт нажатия.

			       - - - - - - -
     Надо отметить, что	системный блок придает значение	факту отжатия
     к-либо клавиши только тогда, когда	отжатой	была к-либо клавиша
     -переключатель. Если же системный блок получает от	клавиатуры
     данное, соответствующее отжатию к-либо другой клавиши (не клавиши
     -переключателя), то он остается равнодушен	к такому факту,	и
     делает переход на пункт 1.	И действительно, чего же удивительного в
     том, что после нажатия на клавишу,	например с изображенным	на ней
     символом "!", эту клавишу отжали ?	Ничего,	так-как	отжатие	этой
     клавиши ничего не означает: ни ввода нового символа "!", ни чего-то
     другого. Тогда почему же для клавиш-переключателей	учитываются факты
     и нажатий и отжатий ? Дело	в следующем: предположим что Вы, например,
     нажали на клавишу "Shift" и не отпуская ее	нажимаете на клавиши с
     изображением букв.	При нажатии на клавишу "Shift" клавиатура сообщит
     системному	блоку скэн-код клавиши "Shift",	после чего системный блок
     поймет, что все буквы, которые будут вводиться с клавиатуры, будут
     иметь прописной вид. Таким	образом, пока Вы не отожмете клавишу
     "Shift" все вводимые с клавиатуры буквы будут иметь прописной вид.
     Как только	Вы отожмете клавишу "Shift", клавиатура	сообщит	системному
     блоку скэн-код клавиши "Shift" + 128 (что означает	отжатие	клавиши
     "Shift"), после чего системный блок поймет, что все буквы,	которые
     будут вводиться с клавиатуры, будут иметь строчный	вид. Таким
     образом, если бы системный	блок не	реагировал на скэн-коды	клавиш
     -переключателей + 128 (т.е. на факты отжатий клавиш-переключателей),
     то	все вводимые буквы (даже после отжатия клавиши "Shift")	имели бы
     прописной вид! Именно поэтому системный блок учитывает факты и
     нажатий и отжатий клавиш-переключателей.
			       - - - - - - -

	8.4> Системный блок проверяет: есть ли свободное место в его
	системном буфере клавиатуры ? Если есть, то делается переход на
	шаг 8.5, иначе издается	звуковой сигнал	и делается переход на
	шаг 1;

			       - - - - - - -
     Системный буфер клавиатуры	(СБК) имеет точно такое	же устройство,
     как и буфер клавиатуры (если не считать небольшие отличия). Прежде
     рассматривать системный буфер клавиатуры интересно	выяснить: а зачем,
     собственно, он вообще нужен компьютеру ?

     Итак мы знаем, что	в клавиатуре есть буфер	клавиатуры, в котором
     временно (пока не считает системный блок) хранится	информация о тех
     фактах нажатия и отпускания клавиш, которые еще не	успели приняться
     системным блоком. Если бы в клавиатуре не было буфера клавиатуры, то
     вся информация о фактах нажатия и отпускания клавиш, которые бы
     происходили в то время, когда системный блок не мог (т.к. был занят
     более важным делом) выполнить просьбы клавиатуры о	выполнении
     прерывания	№9, были бы безвозвратно утеряны. А так-как клавиатура
     имеет буфер клавиатуры, то	вся эта	информация сохраняется и когда
     системный блок начинает мочь выполнять прерывание №9, то вся она
     благополучно им обработается.

     В системном блоке есть подобие буфера клавиатуры -	это системный
     буфер клавиатуры (СБК), в котором временно	(пока их не считает наша
     или к-либо	другая компьютерная программа) хранятся	те данные, которые
     были введены с клавиатуры:	буквы, цифры, различные	знаки ("*/-+!")	и
     т.д. Если бы в системном блоке не было СБК, то системный блок мог бы
     запомнить лишь ту поступившую в него информацию от	клавиатуры,
     которая бы	поступила последней (это потому, что последние поступившая
     информация	записалась бы на тоже самое место, где бы хранилась еще	не
     считанная нашей программой	ранее туда записанная информация). А это
     значило бы, что вся информация, которая поступила в системный блок
     перед последнее поступившей информацией, безвозвратно утеряна.
     Поэтому в системном блоке и устроили СБК, чтобы он	сохранял
     поступившую с клавиатуры информацию до тех	пор, пока она не
     понадобится работающей (например нашей) компьютерной программе.

     Системный буфер клавиатуры	изображен на рис. 3. Системный буфер
     клавиатуры	можно представить как таблицу из 16 ячеек (элементов),
     каждая из которых состоит из 2 байтов (частей). Каждый байт ячейки
     СБК может содержать к-либо	число от 0 до 255. Все байты ячеек СБК
     пронумерованы от 30 до 61.	Кроме 32 байтов	в буфере клавиатуры
     имеются 2 специальные ячейки: это так называемые ячейка "хвоста" и
     ячейка "головы". Каждая из	этих ячеек содержит к-либо число от 30
     до	60, которое соответствует началу к-либо	ячейки буфера клавиатуры.
     Например, если в ячейке "головы" находится	число 32, то это число
     соответствует байту №32 (началу ячейки №2).

		 Устройство системного буфера клавиатуры.
		 ........................................

	    ┌───────┬───────┐		     ┌───────────────────┐
	    │30	байт│31	байт│	 Ячейка	№1   │ Байт "головы" СБК │
     З	│   ├───────┼───────┤		     │			 │
     а	│   │32	байт│33	байт│	 Ячейка	№2   ├───────────────────┤
     п	│   ├──┬────┴───────┤		   ┌─┤	      32	 │
     о	│   .  └───────────────────────────┘ └───────────────────┘
     л	│   ├───────┬───────┤
     н	│   │42	байт│43	байт│	 Ячейка	№7   ┌───────────────────┐
     е	│   ├──┬────┴───────┤		     │ Байт "хвоста" СБК │
     н	│   .  └───────────────┐	     │			 │
     и	√   ├───────┬───────┤  │	     ├───────────────────┤
     е	    │60	байт│61	байт│  │ Ячейка	№16 ┌┤	      42	 │
	    └───────┴───────┘  └────────────┘└───────────────────┘

				  Рис. 3

	С помощью системного буфера клавиатуры наши программы узнают о
	том, какие буквы, знаки	и т.д. были введены с клавиатуры.
	С помощью наших	программ мы можем узнать содержимое системного
	буфера клавиатуры, а также значения ячеек "головы" и "хвоста".
	Например, если значения	ячеек "хвоста" и "головы" будут	равны, то
	это будет означать, что	СБК весь пуст (никакие данные с	клавиатуры
	не поступали), а если значение ячейки "хвоста" не будет	равно
	значению ячейки	"головы", то это будет означать, что в СБК есть
	для нас	какая-то информация. Кроме этого, у нас	есть возможность
	произвольно изменять содержимое	системного буфера клавиатуры и
	значения его ячеек "головы" и "хвоста".	Такое изменение	ячеек
	"головы" и "хвоста"будет создавать иллюзию либо	нажатия	к-либо
	клавиши	на клавиатуре (хотя ее никто и не нажимал), либо наоборот
	- как будто ничего не нажималось (хотя фактически данные с
	клавиатуры вводились). Как это сделать будет рассмотренно в [6].
			       - - - - - - -

       8.5> Если нажатой клавише принято ставить в соответствие	символ,
       порядковый номер	которого должен	называться ASCII кодом,	то
       системный блок поместит в свободную ячейку СБК (ее номер	системный
       блок усмотрит в ячейке "хвоста")	следующее:
       - в первый байт ячейки: порядковый номер	(который теперь	называется
	 ASCII кодом) символа, соответствующего	клавише;
       - во второй байт: скэн-код (порядковый номер) той клавиши, которую
	 нажимали и которой был	поставлен в соответствие символ;
       После этого делается переход на шаг 1;

       8.6> Если нажатой клавише принято ставить в соответствие	символ,
       порядковый номер	которого должен	называться расширенным ASCII
       кодом, то системный блок	поместит в свободную ячейку СБК	(ее номер
       системный блок усмотрит в ячейке	"хвоста") следующее:
       - в первый байт ячейки: число 0 (число 0	как-раз	и указывает на
	 то, что в данной ячейке СБК находится порядковый номер	символа,
	 который теперь	называется не ASCII кодом, а расширенным ASCII
	 кодом);
       - во второй байт: порядковый номер (который теперь называется
	 расширенным ASCII кодом) символа, соответствующего клавише;

			       - - - - - - -
     Нужно отметить, что системный блок	умеет различать	не только факты
     нажатия и отжатия отдельной клавиши, но и факты нажатия и отжатия
     некоторых определенных комбинаций клавиш. Эти комбинации получаются
     при совместном нажатии одной или нескольких клавиш-переключателей и
     к-либо другой клавиши. Подобную комбинацию	можно получить,	например,
     если нажать на клавишу "Alt" и не отпуская	ее нажать на клавишу "F1".
     Такое совместное нажатие клавиш системный блок воспринимает как
     нажатие на	к-либо одну "новую" клавишу. В таблице [5.1] приведены все
     возможные комбинации клавиш, которые системный блок принимает за одну
     "виртуальную" клавишу.

     Как же системный блок распознает комбинации из нажатых клавиш ?
     Рассмотрим, например, как системный блок распознает следующую
     комбинацию	из трех	нажатых	клавиш:	"Ctrl",	"Alt", "F1", т.е. сперва
     нажимают на клавишу "Ctrl"	и не отпуская ее нажимают на клавишу
     "Alt" и клавишу "F1". Итак:
       1) При нажатии на клавишу "Ctrl"	клавиатура передает системному
       блоку скэн-код клавиши "Ctrl". Системный	блок поняв, что	на
       клавиатуре нажали на клавишу-переключатель "Ctrl", сразу
       зафиксирует этот	факт в ОЗУ по адресам 417h и 418h;
       2) Теперь (не отжимая клавишу "Ctrl") на	клавиатуре нажимают на
       клавишу "Alt". Теперь клавиатура	передает системному блоку скэн-код
       клавиши "Alt". Системный	блок поняв, что	на клавиатуре нажали на
       клавишу-переключатель "Alt", сразу зафиксирует этот факт	в ОЗУ по
       адресам 417h и 418h;
       3) Теперь (не отжимая клавишу "Ctrl" и клавишу "Alt") на	клавиатуре
       нажимают	на клавишу "F1". Теперь	клавиатура передает системному
       блоку скэн-код клавиши "F1". Системный блок поняв, что на
       клавиатуре нажали на клавишу "F1", сразу	смотрит: в ОЗУ по адресам
       417h и 418h зафиксирован	ли какой-нибудь	факт того, что к-либо
       клавиша-переключатель находится в нажатом состоянии (если клавиша
       находится в нажатом состоянии, то системный блок	получал	от
       клавиатуры только ее скэн-код (при ее нажатии), а скэн-код + 128
       (при ее отжатии)	он не получал).	Если никаких фактов нажатий на
       клавиши-переключатели не	зафиксированно,	то системный блок (как
       обычно) записывает в системный буфер клавиатуры соответствующие
       клавише "F1" данные. А если к-либо факты	нажатия	на клавиши
       -переключатели зафиксированы (в ОЗУ адресам 417h	и 418h), то
       системный блок записывает в системный буфер клавиатуры данные,
       соответствующие не клавише "F1",	а комбинации из	нажатых	клавиш-
       переключателей (в нашем примере это клавиша "Ctrl" и клавиша "Alt")
       и к-либо	клавиши	(в нашем примере это клавиша "F1");
       4) При отжатии клавиши "F1" клавиатура передаст системному блоку
       скэн-код	клавиши	"F1" + 128. Системный блок поймет, что на
       клавиатуре отжали клавишу "F1", и он проигнорирует этот факт, т.к.
       этот факт ему ни	о чем интересном не говорит;
       5) При отжатии клавиши "Alt" клавиатура передаст	системному блоку
       скэн-код	клавиши	"Alt" +	128. Системный блок поймет, что	на
       клавиатуре отжали клавишу "Alt",	и он сразу же зафиксирует этот
       факт (т.е. факт отжатия клавиши "Alt") в	ОЗУ по адресам 417h и 418h
       (этот факт для него достаточно важен);
       6) При отжатии клавиши "Ctrl" клавиатура	передаст системному блоку
       скэн-код	клавиши	"Ctrl"" + 128. Системный блок поймет, что на
       клавиатуре отжали клавишу "Ctrl"", и он сразу же зафиксирует этот
       факт (т.е. факт отжатия клавиши "Ctrl"") в ОЗУ по адресам 417h и
       418h (этот факт для него	достаточно важен);

       Если теперь мы снова нажмем на клавишу "F1", то системный блок,
       получив от клавиатуры скэн-код клавиши "F1" и увидев, что в ОЗУ по
       адресам 417h и 418h нет информации о нажатии к-либо клавиши
       -переключателя, запишет в системный буфер клавиатуры (как и обычно)
       данные, соответствующие клавише "F1";
			       - - - - - - -

     9>	Переход	на шаг 1.

			       * * * * * * *

		      [4] ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ.
		      ******************************

			     [4.1] Автоповтор.
			     =================
     При вводе информации с клавиатуры часто бывает необходимо нажимать
     несколько раз в подряд одну и ту же клавишу. Например: нам	необходимо
     ввести с клавиатуры такую строку "************". Для этого	мы должны
     нажать и отпустить	клавишу	с изображением "*" 12 раз. Для того, чтобы
     это было не так утомительно и более быстро	придумали следующее: если
     мы	нажимаем на к-либо клавишу и удерживаем	ее в нажатом состоянии
     больше чем	обычно,	то контроллер клавиатуры понимает, что мы хотим
     ввести несколько одинаковых данных, например символов "*",	и поэтому
     он	начинает за нас	"отпускать и нажимать" нажатую клавишу,	до тех
     пор, пока мы ее не	отпустим.

	Рассмотрим механизм автоповтора.
     Нажмем, например, на клавишу с изображением "*" и будем удерживать	ее
     в нажатом состоянии больше	чем обычно. При	этом произойдет	следующее:
     при обнаружении факта нажатия на клавишу '*' контроллер клавиатуры
     запишет в свободную ячейку	буфера клавиатуры скэн-код нажатой
     клавиши, равный 9.	После этого контроллер клавиатуры обнаружит, что
     клавиша нажата больше чем обычно, и поэтому в следующую ячейку буфера
     клавиатуры	он снова запишет код нажатой клавиши, т.е. число 9. До тех
     пор, пока мы не отпустим нажатую клавишу контроллер клавиатуры будет
     записывать	в следующие ячейки скэн-код, равный 9. Как только мы
     отпустим нажатую клавишу контроллер клавиатуры запишет в следующую
     ячейку число 9+128, означающий что	нажатая	клавиша	была отпущена.

     Таким образом, анализируя информацию, посылаемую  клавиатурой,
     системный блок узнает, какие клавиши действительно	нажимались и
     отпускались много раз, а какие были нажаты, удержаны больше чем
     обычно, а после отпущены.	Надо отметить, что системному блоку нет
     разницы, как вводятся данные, путем нажатия и отпускания, либо путем
     нажатия, удерживания и отпускания.	В обоих	случаях	в СБК появятся
     одинаковые	данные.

			       * * * * * * *

			[4.2] Прямой ввод символов
		       в системный буфер клавиатуры.
		       =============================
     Иногда бывает необходимо ввести с клавиатуры к-либо символ, который
     не	изображен ни на	одной клавиши, например	такой '┼'. Как же ввести
     с клавиатуры такой	символ ? Для этого случая программа BIOSа,
     выполняющая прерывание №9,	предоставляет нам метод	прямого	ввода
     символов. Что это за метод	? Суть этого метода состоит в том, что
     если нам нужно ввести к-либо символ, то можно нажать на клавишу 'Alt'
     и удерживая ее нажатой набрать на дополнительной клавиатуре
     десятичный	ASCII код (порядковый номер) нужного символа, после чего
     отжать клавишу 'Alt'. После отжатия клавиши 'Alt' набранный символ
     поместится	в системный буфер клавиатуры.

			       * * * * * * *

		       [4.3] Индикаторы	клавиатуры.
		       ============================
     В клавиатуре имеются 3 миниатюрных	индикатора, которые отображают
     некоторые режимы работы клавиатуры. Это:

     Индикатор:	       Назначение:
     ---------	       -----------
     CapsLock	       Если светится, то включен режим ввода букв в
		       прописном виде, а если не светится, то включен
		       режим ввода букв	в строчном виде.

     NumLock	       Если светится, то включен режим использования
		       клавиш дополнительной клавиатуры	для ввода цифр,
		       а если не светится, то включен режим использования
		       клавиш дополнительной клавиатуры	для перемещения
		       текста и	курсора	по экрану.

     ScrollLock	       Если светится, то включен такой режим работы
		       клавиатуры, при котором нажатия на стрелки будут
		       вызывать	перемещение не курсора по экрану, а
		       изображения (текста,рисунка) на нем.

     Контроллер	клавиатуры включает и выключает	свои индикаторы	лишь по
     командам системного блока.	Мы имеем произвольно включать и	выключать
     индикаторы	клавиатуры. Для	этого нам необходимо написать программу,
     которая бы	отдала соответствующее приказание контроллеру клавиатуры.
     Вскоре мы разберем	подобную программу, а сейчас необходимо	выяснить:
     как включается, например, индикатор "CapsLock" при	первом нажатии на
     клавишу "CapsLock", и как он выключается при втором нажатии на
     клавишу "CapsLock"	?

     Когда мы впервые нажимаем на клавишу "CapsLock", системный	блок
     приказывает контроллеру клавиатуры	включить индикатор "CapsLock",
     а когда мы	повторно нажимаем на клавишу "CapsLock", то системный блок
     приказывает контроллеру клавиатуры	выключить индикатор "CapsLock".
     Точно также происходит и с	индикаторами "NumLock" и "ScrolLock".
     Системный блок включает и выключает индикаторы в то время,	когда он
     выполняет шаг 8.3.
			       * * * * * * *

	  [4.4]	Ввод русских и английских символов с клавиатуры.
	  ======================================================
     При работе	за компьютером Вы наверное вводили буквы не только
     латинского, но и русского алфавита. Каким же так получается, что
     нажимая на	одну и ту же клавишу в одном случае ей соответствует буква
     латинского	алфавита, а в другом случае ей соответствует буква
     русского алфавита ?

     Дело в том, что компьютер может работать с	клавиатурой не всегда
     обычно (нормально). Обычно:
     - нажимая на к-либо буквенную клавишу клавиатура передает системному
       блоку ее	скэн-код (порядковый номер), который преобразуется в нем
       специальной программой BIOSа (выполняющей прерывание №9)	в
       соответствующую букву латинского	алфавита;
     Необычно (искусственно):
     - нажимая на к-либо буквенную клавишу клавиатура передает системному
       блоку ее	скэн-код (порядковый номер), который преобразуется в нем
       не в соответствующую букву латинского алфавита, а в другую (тоже
       вполне определенную) букву русского алфавита, причем это
       преобразование будет делать не программа	BIOSа (которая выполняет
       прерывание №9), а другая	(тоже специальная) компьютерная	программа,
       которая временно	будет выполнять	ее функции;

     Такая специальная программа называется "руссификатор". Используя
     руссификатор мы достигаем того, что при нажатии на	символьную
     клавишу в СБК помещается не соответствующий ей порядковый номер
     латинского	символа, а другой порядковый номер, который соответствует
     русской букве.

     Таким образом, если нам нужно ввести букву	русского алфавита, мы
     даем знать	об этом	руссификатору (например	нажимая	одновременно две
     клавиши "Shift"), который временно	видоизменит выполнение пункта 8.5
     в нашу пользу. Если же нам	нужно будет ввести символ латинского
     алфавита, то мы попросим руссификатор (опять-таки нажимая
     одновременно две клавиши "Shift"),	не влазить в работу системного
     блока при его общении с клавиатурой, и тогда все будет происходить
     как обычно.

			       * * * * * * *

			  [5] ТЕХНИЧЕСКИЕ ДЕТАЛИ.
			  ***********************

	   [5.1] Компьютерные символы и	их порядковые номера.
	   ==================================================

	Примечание.
     Символы с номерами	от 0 по	31 имеют в компьютере специальное
     назначение	и в данном пособии не рассматриваются.
     ┌──────────────────────────────────────────────────────────────────┐
     │		0	@  ....	 64	  А  .... 128	    └  .... 192	│
     │		1	A  ....	 65	  Б  .... 129	    ┴  .... 193	│
     │		2	B  ....	 66	  В  .... 130	    ┬  .... 194	│
     │		3	C  ....	 67	  Г  .... 131	    ├  .... 195	│
     │		4	D  ....	 68	  Д  .... 132	    ─  .... 196	│
     │		5	E  ....	 69	  Е  .... 133	    ┼  .... 197	│
     │		6	F  ....	 70	  Ж  .... 134	    ╞  .... 198	│
     │		7	G  ....	 71	  З  .... 135	    ╟  .... 199	│
     │		8	H  ....	 72	  И  .... 136	    ╚  .... 200	│
     │		9	I  ....	 73	  Й  .... 137	    ╔  .... 201	│
     │	       10	J  ....	 74	  K  .... 138	    ╩  .... 202	│
     │	       11	K  ....	 75	  Л  .... 139	    ╦  .... 203	│
     │	       12	L  ....	 76	  М  .... 140	    ╠  .... 204	│
     │	       13	M  ....	 77	  H  .... 141	    ═  .... 205	│
     │	       14	N  ....	 78	  О  .... 142	    ╬  .... 206	│
     │	       15	O  ....	 79	  П  .... 143	    ╧  .... 207	│
     │	       16	P  ....	 80	  Р  .... 144	    ╨  .... 208	│
     │	       17	Q  ....	 81	  С  .... 145	    ╤  .... 209	│
     │	       18	R  ....	 82	  Т  .... 146	    ╥  .... 210	│
     │	       19	S  ....	 83	  У  .... 147	    ╙  .... 211	│
     │	       20	T  ....	 84	  Ф  .... 148	    ╘  .... 212	│
     │	       21	U  ....	 85	  Х  .... 149	    ╒  .... 213	│
     │	       22	V  ....	 86	  Ц  .... 150	    ╓  .... 214	│
     │	       23	W  ....	 87	  Ч  .... 151	    ╫  .... 215	│
     │	       24	X  ....	 88	  Ш  .... 152	    ╪  .... 216	│
     │	       25	Y  ....	 89	  Щ  .... 153	    ┘  .... 217	│
     │	       26	Z  ....	 90	  Ъ  .... 154	    ┌  .... 218	│
     │	       27	[  ....	 91	  Ы  .... 155	    █  .... 219	│
     │	       28	\  ....	 92	  Ь  .... 156	    ▄  .... 220	│
     │	       29	]  ....	 93	  Э  .... 157	    ▌  .... 221	│
     │	       30	^  ....	 94	  Ю  .... 158	    ▐  .... 222	│
     │	       31	_  ....	 95	  Я  .... 159	    ▀  .... 223	│
     │ пробел  32	`  ....	 96	  а  .... 160	    р  .... 224	│
     │ !  .... 33	a  ....	 97	  б  .... 161	    с  .... 225	│
     │ "  .... 34       b  ....  98       в  .... 162       т  .... 226 │
     │ #  .... 35	c  ....	 99	  г  .... 163	    у  .... 227	│
     │ $  .... 36	d  ....	100	  д  .... 164	    ф  .... 228	│
     │ %  .... 37	e  ....	101	  е  .... 165	    х  .... 229	│
     │ &  .... 38	f  ....	102	  ж  .... 166	    ц  .... 230	│
     │ '  .... 39       g  .... 103       з  .... 167       ч  .... 231 │
     │ (  .... 40	h  ....	104	  и  .... 168	    ш  .... 232	│
     │ )  .... 41	i  ....	105	  й  .... 169	    щ  .... 233	│
     │ *  .... 42	j  ....	106	  к  .... 170	    ъ  .... 234	│
     │ +  .... 43	k  ....	107	  л  .... 171	    ы  .... 235	│
     │ ,  .... 44	l  ....	108	  м  .... 172	    ь  .... 236	│
     │ -  .... 45	m  ....	109	  н  .... 173	    э  .... 237	│
     │ .  .... 46	n  ....	110	  о  .... 174	    ю  .... 238	│
     │ /  .... 47	o  ....	111	  п  .... 175	    я  .... 239	│
     │ 0  .... 48	p  ....	112	  ░  .... 176	    Ё  .... 240	│
     │ 1  .... 49	q  ....	113	  ▒  .... 177	    ё  .... 241	│
     │ 2  .... 50	r  ....	114	  ▓  .... 178	    Є  .... 242	│
     │ 3  .... 51	s  ....	115	  │  .... 179	    є  .... 243	│
     │ 4  .... 52	t  ....	116	  ┤  .... 180	    Ї  .... 244	│
     │ 5  .... 53	u  ....	117	  ╡  .... 181	    ї  .... 245	│
     │ 6  .... 54	v  ....	118	  ╢  .... 182	    Ў  .... 246	│
     │ 7  .... 55	w  ....	119	  ╖  .... 183	    ў  .... 247	│
     │ 8  .... 56	x  ....	120	  ╕  .... 184	    °  .... 248	│
     │ 9  .... 57	y  ....	121	  ╣  .... 185	    ∙  .... 249	│
     │ :  .... 58	z  ....	122	  ║  .... 186	    ·  .... 250	│
     │ ;  .... 59	{  ....	123	  ╗  .... 187	    √  .... 251	│
     │ <  .... 60	|  ....	124	  ╝  .... 188	    №  .... 252	│
     │ =  .... 61	}  ....	125	  ╜  .... 189	    ¤  .... 253	│
     │ >  .... 62	~  ....	126	  ╛  .... 190	    ■  .... 254	│
     │ ?  .... 63	  ....	127	  ┐  .... 191	    пробел  255	│
     └──────────────────────────────────────────────────────────────────┘

			       * * * * * * *

	[5.2] Скэн, ASCII коды и расширенные ASCII коды	клавиатуры,
	  которые считываются с	СБК через прерывание №16h BIOSа
			    системного блока.
	  =====================================================

       Примечание.
     "[!!]" - Этот знак	означает дополнительную	102 клавишу, которая
     имеется на	некоторых заморских клавиатурах. Эта клавиша
     располагается в нижнем левом углу клавиатуры.
     "***" - Этот знак означает, что данное нажатие обрабатывается
     системным блоком, и заносится не в	системный буфер	клавиатуры, а в
     ОЗУ по адресам 417h и 418h.
     "---" - Этот знак означает, что данное нажатие не передается
     клавиатурой в системный блок.

     Будьте внимательны: в ячейках системного буфера клавиатуры	данные
     записываются в обратной последовательности, чем в приведенной
     таблице, например для клавиши "Esc" в СБК записывается не 01/1Bh,
     а 1Bh/01.

     ┌───────────────────────────────────────────────────────────────────┐
     │ Нажатие	    Скэн-код/ASCII код или расширенный ASCII код и 0	 │
     ├─────────────────────────────────┬─────────────────────────────────┤
     │ Esc			01/1B  │  Shift	End		   4F/E0 │
     │ 1			02/31  │  Shift	Down Arrow	   50/E0 │
     │ 2			03/32  │  Shift	Page Down	   51/E0 │
     │ 3			04/33  │  Shift	Insert		   52/E0 │
     │ 4			05/34  │  Shift	Delete		   53/E0 │
     │ 5			06/35  │				 │
     │ 6			07/36  │  Ctrl Esc		   01/1B │
     │ 7			08/37  │  Ctrl 1		    ---	 │
     │ 8			09/38  │  Ctrl 2		   03/00 │
     │ 9			0A/39  │  Ctrl 3		    ---	 │
     │ 0			0B/30  │  Ctrl 4		    ---	 │
     │ -			0C/2D  │  Ctrl 5		    ---	 │
     │ =			0D/3D  │  Ctrl 6		   07/1E │
     │ Backspace		0E/08  │  Ctrl 7		    ---	 │
     │ Tab			0F/09  │  Ctrl 8		    ---	 │
     │ q			10/71  │  Ctrl 9		    ---	 │
     │ w			11/77  │  Ctrl 0		    ---	 │
     │ e			12/65  │  Ctrl -		   0C/1F │
     │ r			13/72  │  Ctrl =		    ---	 │
     │ t			14/74  │  Ctrl Backspace	   0E/7F │
     │ y			15/79  │  Ctrl Tab		   94/00 │
     │ u			16/75  │  Ctrl q		   10/11 │
     │ i			17/69  │  Ctrl w		   11/17 │
     │ o			18/6F  │  Ctrl e		   12/05 │
     │ p			19/70  │  Ctrl r		   13/12 │
     │ [			1A/5B  │  Ctrl t		   14/14 │
     │ ]			1B/5D  │  Ctrl y		   15/19 │
     │ Enter			1C/0D  │  Ctrl u		   16/15 │
     │ Ctrl			 ***   │  Ctrl i		   17/09 │
     │ a			1E/61  │  Ctrl o		   18/0F │
     │ s			1F/73  │  Ctrl p		   19/10 │
     │ d			20/64  │  Ctrl [		   1A/1B │
     │ f			21/66  │  Ctrl ]		   1B/1D │
     │ g			22/67  │  Ctrl Enter		   1C/0A │
     │ h			23/68  │  Ctrl a		   1E/01 │
     │ j			24/6A  │  Ctrl s		   1F/13 │
     │ k			25/6B  │  Ctrl d		   20/04 │
     │ l			26/6C  │  Ctrl f		   21/06 │
     │ ;			27/3B  │  Ctrl g		   22/07 │
     │ '                        28/27  │  Ctrl h                   23/08 │
     │ `			29/60  │  Ctrl j		   24/0A │
     │ Shift			 ***   │  Ctrl k		   25/0B │
     │ \			2B/5C  │  Ctrl l		   26/0C │
     │ z			2C/7A  │  Ctrl ;		    ---	 │
     │ x			2D/78  │  Ctrl '                    ---  │
     │ c			2E/63  │  Ctrl `		    ---	 │
     │ v			2F/76  │  Ctrl Shift		    ***	 │
     │ b			30/62  │  Ctrl \		   2B/1C │
     │ n			31/6E  │  Ctrl z		   2C/1A │
     │ m			32/6D  │  Ctrl x		   2D/18 │
     │ ,			33/2C  │  Ctrl c		   2E/03 │
     │ .			34/2E  │  Ctrl v		   2F/16 │
     │ /			35/2F  │  Ctrl b		   30/02 │
     │ * (дополн. кл)		37/2A  │  Ctrl n		   31/0E │
     │ Alt			 ***   │  Ctrl m		   32/0D │
     │ Space			39/20  │  Ctrl ,		    ---	 │
     │ CapsLock			 ***   │  Ctrl .		    ---	 │
     │ F1			3B/00  │  Ctrl /		    ---	 │
     │ F2			3C/00  │  Ctrl * (дополн. кл)	   96/00 │
     │ F3			3D/00  │  Ctrl Alt		    ***	 │
     │ F4			3E/00  │  Ctrl Space		   39/20 │
     │ F5			3F/00  │  Ctrl CapsLock		    ---	 │
     │ F6			40/00  │  Ctrl F1		   5E/00 │
     │ F7			41/00  │  Ctrl F2		   5F/00 │
     │ F8			42/00  │  Ctrl F3		   60/00 │
     │ F9			43/00  │  Ctrl F4		   61/00 │
     │ F10			44/00  │  Ctrl F5		   62/00 │
     │ F11			85/00  │  Ctrl F6		   63/00 │
     │ F12			86/00  │  Ctrl F7		   64/00 │
     │ NumLock			 ***   │  Ctrl F8		   65/00 │
     │ ScrollLock		 ***   │  Ctrl F9		   66/00 │
     │ 7 (дополн. кл)		47/00  │  Ctrl F10		   67/00 │
     │ 8 (дополн. кл)		48/00  │  Ctrl F11		   89/00 │
     │ 9 (дополн. кл)		49/00  │  Ctrl F12		   8A/00 │
     │ - (дополн. кл)		4A/2D  │  Ctrl NumLock		    ---	 │
     │ 4 (дополн. кл)		4B/00  │  Ctrl ScrollLock	    ---	 │
     │ 5 (дополн. кл)		4C/00  │  Ctrl 7 (дополн. кл)	   77/00 │
     │ 6 (дополн. кл)		4D/00  │  Ctrl 8 (дополн. кл)	   8D/00 │
     │ + (дополн. кл)		4E/2B  │  Ctrl 9 (дополн. кл)	   84/00 │
     │ 1 (дополн. кл)		4F/00  │  Ctrl - (дополн. кл)	   8E/00 │
     │ 2 (дополн. кл)		50/00  │  Ctrl 4 (дополн. кл)	   73/00 │
     │ 3 (дополн. кл)		51/00  │  Ctrl 5 (дополн. кл)	   8F/00 │
     │ 0 (дополн. кл)		52/00  │  Ctrl 6 (дополн. кл)	   74/00 │
     │ . (дополн. кл)		53/00  │  Ctrl + (дополн. кл)	   90/00 │
     │ SysReq			 ***   │  Ctrl 1 (дополн. кл)	   75/00 │
     │ [!!]			56/5C  │  Ctrl 2 (дополн. кл)	   91/00 │
     │ Enter (дополн. кл)	E0/0D  │  Ctrl 3 (дополн. кл)	   76/00 │
     │ / (дополн. кл)		E0/2F  │  Ctrl 0 (дополн. кл)	   92/00 │
     │ PrintScreen		 ***   │  Ctrl . (дополн. кл)	   93/00 │
     │ Pause			 ***   │  Ctrl SysReq		    ***	 │
     │ Home			47/E0  │  Ctrl [!!]		    ---	 │
     │ Up Arrow			48/E0  │  Ctrl Enter (дополн. кл)  E0/0A │
     │ Page Up			49/E0  │  Ctrl / (дополн. кл)	   95/00 │
     │ Left Arrow		4B/E0  │  Ctrl PrintScreen	   72/00 │
     │ Right Arrow		4D/E0  │  Ctrl Break		   00/00 │
     │ End			4F/E0  │  Ctrl Home		   77/E0 │
     │ Down Arrow		50/E0  │  Ctrl Up Arrow		   8D/E0 │
     │ Page Down		51/E0  │  Ctrl Page Up		   84/E0 │
     │ Insert			52/E0  │  Ctrl Left Arrow	   73/E0 │
     │ Delete			53/E0  │  Ctrl Right Arrow	   74/E0 │
     │				       │  Ctrl End		   75/E0 │
     │ Shift Esc		01/1B  │  Ctrl Down Arrow	   91/E0 │
     │ !			02/21  │  Ctrl Page Down	   76/E0 │
     │ @			03/40  │  Ctrl Insert		   92/E0 │
     │ #			04/23  │  Ctrl Delete		   93/E0 │
     │ $			05/24  │				 │
     │ %			06/25  │  Alt Esc		   01/00 │
     │ ^			07/5E  │  Alt 1			   78/00 │
     │ &			08/26  │  Alt 2			   79/00 │
     │ *			09/2A  │  Alt 3			   7A/00 │
     │ (			0A/28  │  Alt 4			   7B/00 │
     │ )			0B/29  │  Alt 5			   7C/00 │
     │ _			0C/5F  │  Alt 6			   7D/00 │
     │ +			0D/2B  │  Alt 7			   7E/00 │
     │ Shift Backspace		0E/08  │  Alt 8			   7F/00 │
     │ Shift Tab		0F/00  │  Alt 9			   80/00 │
     │ Q			10/51  │  Alt 0			   81/00 │
     │ W			11/57  │  Alt -			   82/00 │
     │ E			12/45  │  Alt =			   83/00 │
     │ R			13/52  │  Alt Backspace		   0E/00 │
     │ T			14/54  │  Alt Tab		   A5/00 │
     │ Y			15/59  │  Alt q			   10/00 │
     │ U			16/55  │  Alt w			   11/00 │
     │ I			17/49  │  Alt e			   12/00 │
     │ O			18/4F  │  Alt r			   13/00 │
     │ P			19/50  │  Alt t			   14/00 │
     │ {			1A/7B  │  Alt y			   15/00 │
     │ }			1B/7D  │  Alt u			   16/00 │
     │ Shift Enter		1C/0D  │  Alt i			   17/00 │
     │ Shift Ctrl		 ***   │  Alt o			   18/00 │
     │ A			1E/41  │  Alt p			   19/00 │
     │ S			1F/53  │  Alt [			   1A/00 │
     │ D			20/44  │  Alt ]			   1B/00 │
     │ F			21/46  │  Alt Enter		   1C/00 │
     │ G			22/47  │  Alt Ctrl		    ***	 │
     │ H			23/48  │  Alt a			   1E/00 │
     │ J			24/4A  │  Alt s			   1F/00 │
     │ K			25/4B  │  Alt d			   20/00 │
     │ L			26/4C  │  Alt f			   21/00 │
     │ :			27/3A  │  Alt g			   22/00 │
     │ "                        28/22  │  Alt h                    23/00 │
     │ ~			29/7E  │  Alt j			   24/00 │
     │ |			2B/7C  │  Alt k			   25/00 │
     │ Z			2C/5A  │  Alt l			   26/00 │
     │ X			2D/58  │  Alt ;			   27/00 │
     │ C			2E/43  │  Alt '                    28/00 │
     │ V			2F/56  │  Alt `			   29/00 │
     │ B			30/42  │  Alt Shift		    ***	 │
     │ N			31/4E  │  Alt \			   2B/00 │
     │ M			32/4D  │  Alt z			   2C/00 │
     │ <			33/3C  │  Alt x			   2D/00 │
     │ >			34/3E  │  Alt c			   2E/00 │
     │ ?			35/3F  │  Alt v			   2F/00 │
     │ Shift * (дополн.	кл)	37/2A  │  Alt b			   30/00 │
     │ Shift Alt		 ***   │  Alt n			   31/00 │
     │ Shift Space		39/20  │  Alt m			   32/00 │
     │ Shift CapsLock		 ***   │  Alt ,			   33/00 │
     │ Shift F1			54/00  │  Alt .			   34/00 │
     │ Shift F2			55/00  │  Alt /			   35/00 │
     │ Shift F3			56/00  │  Alt *	(дополн. кл)	   37/00 │
     │ Shift F4			57/00  │  Alt Space		   39/20 │
     │ Shift F5			58/00  │  Alt CapsLock		    ***	 │
     │ Shift F6			59/00  │  Alt F1		   68/00 │
     │ Shift F7			5A/00  │  Alt F2		   69/00 │
     │ Shift F8			5B/00  │  Alt F3		   6A/00 │
     │ Shift F9			5C/00  │  Alt F4		   6B/00 │
     │ Shift F10		5D/00  │  Alt F5		   6C/00 │
     │ Shift F11		87/00  │  Alt F6		   6D/00 │
     │ Shift F12		88/00  │  Alt F7		   6E/00 │
     │ Shift NumLock		 ***   │  Alt F8		   6F/00 │
     │ Shift ScrollLock		 ***   │  Alt F9		   70/00 │
     │ Shift 7 (дополн.	кл)	47/37  │  Alt F10		   71/00 │
     │ Shift 8 (дополн.	кл)	48/38  │  Alt F11		   8B/00 │
     │ Shift 9 (дополн.	кл)	49/39  │  Alt F12		   8C/00 │
     │ Shift - (дополн.	кл)	4A/2D  │  Alt NumLock		    ***	 │
     │ Shift 4 (дополн.	кл)	4B/34  │  Alt ScrollLock	    ***	 │
     │ Shift 5 (дополн.	кл)	4C/35  │  Alt -	(дополн. кл)	   4A/00 │
     │ Shift 6 (дополн.	кл)	4D/36  │  Alt +	(дополн. кл)	   4E/00 │
     │ Shift + (дополн.	кл)	4E/2B  │  Alt Del		    ---	 │
     │ Shift 1 (дополн.	кл)	4F/31  │  Alt SysReq		    ***	 │
     │ Shift 2 (дополн.	кл)	50/32  │  Alt [!!]		    ---	 │
     │ Shift 3 (дополн.	кл)	51/33  │  Alt Enter (дополн. кл)   A6/00 │
     │ Shift 0 (дополн.	кл)	52/30  │  Alt /	(дополн. кл)	   A4/00 │
     │ Shift . (дополн.	кл)	53/2E  │  Alt PrintScreen	    ***	 │
     │ Shift SysReq		 ***   │  Alt Pause		    ***	 │
     │ Shift [!!]		56/7C  │  Alt Home		   97/00 │
     │ Shift Enter (дополн. кл)	E0/0D  │  Alt Up Arrow		   98/00 │
     │ Shift / (дополн.	кл)	E0/2F  │  Alt Page Up		   99/00 │
     │ Shift PrintScreen	 ***   │  Alt Left Arrow	   9B/00 │
     │ Shift Pause		 ***   │  Alt Right Arrow	   9D/00 │
     │ Shift Home		47/E0  │  Alt End		   9F/00 │
     │ Shift Up	Arrow		48/E0  │  Alt Down Arrow	   A0/00 │
     │ Shift Page Up		49/E0  │  Alt Page Down		   A1/00 │
     │ Shift Left Arrow		4B/E0  │  Alt Insert		   A2/00 │
     │ Shift Right Arrow	4D/E0  │  Alt Delete		   A3/00 │
     ├─────────────────────────────────┴─────────────────────────────────┤
     │ Alt 7 (дополн. кл)	    ┐					 │
     │ Alt 8 (дополн. кл)	    │	 Данные	комбинации клавиш	 │
     │ Alt 9 (дополн. кл)	    │	 используются для прямого ввода	 │
     │ Alt 4 (дополн. кл)	    │	 ASCII кодов в системный буфер	 │
     │ Alt 5 (дополн. кл)	    ├──	 клавиатуры и поэтому информация │
     │ Alt 6 (дополн. кл)	    │	 о данных комбинациях клавиш не	 │
     │ Alt 1 (дополн. кл)	    │	 записываются в	системный буфер	 │
     │ Alt 2 (дополн. кл)	    │	 клавиатуры.			 │
     │ Alt 3 (дополн. кл)	    ┘					 │
     └───────────────────────────────────────────────────────────────────┘

			       * * * * * * *

			 [6] РАБОТА С КЛАВИАТУРОЙ.
			 *************************

     Перед тем,	как начать писать к-либо программу, например программу
     для управления клавиатурой, нам необходимо	определиться: какими
     средствами	мы будем пользоваться при ее написании.

     Средства программирования следующие:

     ┌─────────────────┐   1> Язык программирования - это специальная
     │ Язык программи- │   программа, при помощи которой можно
     │ рования	       │   создавать свои программы. Для этого необходимо
     └────────┬────────┘   знать ее особенности, правила написания
	      │		   программ в ее среде.	Для создания программ
	      │		   мы будем пользоваться языком	программирования
	      │		   "Turbo Pascal" версии 6.0 и выше. Данный язык
	      │		   дает	большие	возможности для	написания
	      │		   программ.
	      │
     ┌────────V────────┐   2> Операционная система - это несколько
     │ Операционная    │   важнейших программ, при помощи которых
     │ система (ОС)    │   компоненты компьютера объединяются в	единое
     └────────┬────────┘   целое программным путем и без которых компьютер
	      │		   работать не может. Язык "Turbo Pascal" дает
	      │		   возможность воспользоваться средствами
	      │		   операционной	системы, хотя мы этого делать не
	      │		   будем. Использование	возможностей операционной
	      │		   системы осуществляется путем	использования
	      │		   прерываний.
     ┌────────V────────┐
     │ Средства	BIOS   │   3> Средства BIOS - это набор	специальных
     └────────┬────────┘   программ, постоянно хранящихся в памяти
	      │		   компьютера. Язык "Turbo Pascal" дает
	      │		   возможность воспользоваться средствами BIOS.
	      │		   Использование возможностей BIOS осуществляется
	      │		   путем использования прерываний (как и в
	      │		   случаи с использованием средств операционной
     ┌────────V────────┐   системы).
     │ Порты  ввода /  │
     │ вывода информ.  │   4>  Программирование	на уровне портов
     └─────────────────┘   является наиболее трудоемким	видом
			   программирования. Для этого необходимо хорошо
     разбираться в устройстве компьютера. Несмотря на трудоемкость этого
     уровня он имеет существенный плюс:	программы этого	уровня
     непосредственно управляют электроникой компьютера,	что позволяет
     использовать все ее возможности, и	работают такие программы наиболее
     быстро по сравнению с любым другим	уровнем.

     Чем ниже используемый уровень программирования, тем быстрее работают
     программы,	тем больше у них возможностей в	управлении аппаратурой,	но
     и тем более они сложны и написание	их более трудоемко.

     Принцип программирования таков: используйте средства программирования
     как можно более высокого уровня, т.е. если	данную задачу можно решить
     языком программирования, то не стоит использовать уровень BIOSа или
     портов, т.к. это только усложнит программу	и повысит вероятность
     появления ошибок.


	     [6.1] Использования стандарных возможностей языка
		 "Turbo Pascal"	для работы с клавиатурой.
		 ========================================
     Примеры работы с клавиатурой, которые мы будем рассматривать в
     этом разделе, интересны тем, что все они работают не с клавиатурой,
     как таковой, а с данными СБК, причем используются только обычные
     (стандартные) возможности языка "Turbo Pascal".

     Что значит	"работает не с клавиатурой, а с данными СБК"? Это означает
     следующее:	при нажатии клавиш клавиатуры системный	блок заносит
     соответствующую им	информацию в СБК, где она благополучно лежит до
     тех пор, пока ее не считает оттуда	наша программа.	Если же	"Turbo
     Pascal" увидит, что нашей программе вот-вот понадобится считать
     информацию	из СБК,	а ее там нет (т.к. на клавиши клавиатуры еще никто
     не	нажимал), то "Turbo Pascal" остановит выполнение нашей программы и
     сообщит системному	блоку,что нашей	программе срочно необходимы данные
     из	СБК. Системный блок, поняв проблему, кидает все	свои дела и начнет
     ждать с клавиатуры	к-либо данные. Как только с клавиатуры поступят
     данные системный блок занесет в СБК соответствующую им информацию,
     после чего	он сообщит "Turbo Pascalю", что	в СБК уже появилась
     информация	и проблемы больше нет. Теперь "Turbo Pascal" возобновит
     выполнение	нашей программы, которая благополучно (т.к. данные в СБК
     точно есть) считает данные	из СБК.

     Управление	клавиатурой таким способом имеет следующие особенности:
     - очень просто выполняются	наши желания по	вводу с	клавиатуры
       символов	и символьных строк (пример строки: "*!ЭТО СТРОКА!*"),
       причем нам нет никакой необходимости знать к-либо тонкости работы
       клавиатуры, а также то, каким образом данные с клавиатуры поступают
       в нашу программу;
     - недостаток этого	метода состоит в том, что он дает нам очень
       ограниченные возможности	по управлению клавиатурой.

		     [6.1.1] Ввод данных с клавиатуры.
		     ---------------------------------
     Этот пример показывает, каким образом можно ввести	с клавиатуры
     различные символы:	буквы, цифры и т.д. Когда может	пригодится этот
     пример ? Например тогда, когда Вашей программе необходимо узнать
     сколько Вам лет или как Ваше имя.
			       - - - - - - -
     { Данная программа	считывает последовательность символов: букв,
     цифр, специальных знаков ("!+-" и т.д.) с СБК. Если в СБК ничего
     нет, то программа остановится до тех пор, пока в нем чего-нибудь
     не	появится. После	появления данных в СБК программа возобновит свою
     работу и считает все содержимое СБК }
     var Stt: string; {	В этой переменной будут	находится те символы,
     которые будут введены с клавиатуры	}
     begin { Начало программы }
       writeln ('Введите несколько символов ...'); {Выдать на экран фразу}
       readln (Stt); { Эта команда считает содержимое СБК в
       переменную "Stt"	}
       writeln ('Спасибо за ',Stt); { Эта команда распечатает на экране
       содержимое переменной "Stt" }
     end.  { Конец программы }
			       * * * * * * *

	    [6.2] Использования	расширенных возможностей языка
		 "Turbo Pascal"	для работы с клавиатурой.
		 ========================================
     Примеры работы с клавиатурой, которые мы будем рассматривать в
     этом разделе, интересны тем, что все они работают не с клавиатурой,
     как таковой, а с данными СБК, причем используются не обычные, а
     расширенные возможности языка "Turbo Pascal".

     Что значит	"работает не с клавиатурой, а с данными СБК" смотрите в
     [6.1].

     Управление	клавиатурой таким способом имеет следующие особенности:
     - просто выполняются наши желания по вводу	с клавиатуры символов
       (если говорить точнее, то символы вводится не с клавиатуры, а с
       СБК), причем нам	нет необходимости знать	к-либо тонкости	работы
       клавиатуры, а также то, каким образом данные с клавиатуры поступают
       в нашу программу;
     - недостаток этого	метода состоит в том, что он дает нам ограниченные
       возможности по управлению клавиатурой.

		[6.2.1]	Проверка наличия данных	в системном
			    буфере клавиатуры.
			    ------------------
     Этот пример показывает, каким образом Ваша	программа может	узнать,
     есть ли какие-нибудь данные в СБК или нет (т.е. ввели ли чего-нибудь
     с клавиатуры или нет). Когда может	пригодится этот	пример ? Если, к
     примеру, Вы делаете компьютерный мультфильм,то он должен показываться
     на	экране не бесконечно, а	до тех пор, пока он нам	не надоест. А как
     мультфильму узнать, что он	нам уже	надоел ? Очень просто: если он нам
     надоест, то мы начнем злостно бить	по клавишам, и информация об этих
     ужасных фактах запишется в	СБК (причем Ваша программа даже	и не
     заметит, когда системный блок будет записывать данные в СБК!) и после
     всех этих ужасов СБК не будет больше пустым. Поэтому, если	Ваш
     мультфильм	хочет сделать доброе дело, он должен время от времени
     посматривать: не появились	ли данные в СБК, и как только они там
     появятся, ему нужно сделать доброе	дело, т.е. закончит свою работу,
     поняв, что	он уже надоел.
			       - - - - - - -
     { Данная программа	проверяет наличие к-либо данных	в СБК }
     uses crt; { Подключим к этой программе расширенные	возможности для
     работы с клавиатурой }
     begin { Начало программы }
       ClrScr; { Очистим экран дисплея }
       writeln ('Если хотите чтобы в СБК была к-либо информация, '+
       'то нажмите чего-нибудь ...');
       delay (3000); { Сделаем паузу в 3с (чтобы можно было успеть нажать
       на к-либо клавиши), перед тем как проверять наличие данных в СБК	}
       { Проверим наличие данных в СБК и сообщим результат проверки }
       if KeyPressed=False then	writeln	('СБК пуст!') else writeln
       ('В СБК имеются данные о фактах ввода с клавиатуры.');
     end.  { Конец программы }
			       * * * * * * *

		    [6.2.2] Считывание данного из СБК.
		    ----------------------------------
     Этот пример показывает, каким образом можно считать данное	из СБК.
     Когда может пригодится этот пример	? Например тогда,когда Вашей
     программе необходимо узнать, какой	символ ввели с клавиатуры или
     какую нажали клавишу на клавиатуре: ведь любой нажатой на клавиатуре
     клавише (кроме клавиш-переключателей), включая и клавишу "Ins(ert)",
     системный блок ставит в соответствие к-либо символ, порядковый номер
     которого записывается в СБК и называется либо ASCII кодом,	либо
     расширенным ASCII кодом. В	таблице	[5.1] Вы можете	посмотреть
     порядковые	номера всех символов, которые имеются в	компьютере, а в
     таблице [5.2] приведены данные, которые записываются в ячейки СБК
     после нажатия на клавиши клавиатуры.
			       - - - - - - -
     { Данная программа	считывает тот порядковый номер символа в СБК,
     который поступил туда раньше всех.	Предположим, что содержимое СБК
     следующее:
     ┌─∙∙∙∙∙┬─────┬─────┬─∙∙∙∙∙┐
     │	    │ 3Bh │ 27h	│      │
     └─∙∙∙∙∙┴─────┴─────┴─∙∙∙∙∙┘
	       │     └ Это скэн-код той	клавиши, на которой изображен
	       │       символ ";" и которая была нажата	на клавиатуре.
     Это порядковый номер символа ";". Этот символ был поставлен системным
     блоком в соответствие нажатой клавише со скэн-кодом, равным 27h. В
     данном примере порядковый номер символа ";", равный 27h, называется
     ASCII кодом, т.к. рядом с порядковым номером символа ";" находится
     скэн-код той клавиши, которую нажимали при	вводе символа ";".

       В данном	случае программа считает из СБК	число 3Bh, после чего
     она напечатает на экране символ, порядковый номер которого	равен 3Bh,
     т.е. символ ";". Но надо отметить,	что скэн-код той клавиши, которую
     мы	нажимали при вводе символа ";" (он равен 27h) не считывается этой
     программой	(для этого не хватает расширенных возможностей языка
     "Turbo Pascal"). Если нам будет необходимо	узнать,	какой скэн-код
     соответствует введенному символу (т.е. какая клавиша нажималась при
     его вводе), то нужно воспользоваться возможностями	BIOS (смотрите
     [6.4.1]).

     Содержимое	СБК может быть и такое:
     ┌─∙∙∙∙∙┬─────┬─────┬─∙∙∙∙∙┐
     │	    │ 00h │ 3Bh	│      │
     └─∙∙∙∙∙┴─────┴─────┴─∙∙∙∙∙┘
	       │     └ Это порядковый номер символа ";", который был
	       │       поставлен системным блоком в соответствие нажатой
	       │       на клавиатуре клавише "F1" (в подобных случаях
	       │       скэн-код	нажатой	клавиши	в СБК не записывается).
	       │       В данном	примере	порядковый номер символа ";",
	       │       равный 3Bh, называется расширенным ASCII	кодом,
	       │       т.к. рядом с порядковым номером символа ";"
	       │       находится число ноль.
     Ноль означает то, что находящийся рядом порядковый	номер символа
     называется	не ASCII кодом,	а расширенным ASCII кодом.

	В данном случае	программа считает из СБК число 00h. После этого
     она поймет, что на	клавиатуре нажалась такая клавиша, которой
     ставится в	соответствие символ, порядковый	номер которого в данном
     случае будет называться расширенным ASCII кодом, а	не обычным ASCII
     кодом, и поэтому она снова	начнет считывать с СБК.	То, что	она
     считает оттуда (в данном случае это будет число 3Bh), она примет за
     порядковый	номер (который в данном	случае будет называться
     расширенным ASCII кодом) соответствующего нажатой на клавиатуре
     клавиши символа
			       - - - - - - - }
     uses crt; { Подключим к этой программе расширенные	возможности для
     работы с клавиатурой }
     var Fl: boolean; {	Если эта программа считает из СБК символ,
     порядковый	номер которого называется ASCII	кодом, то переменной "Fl"
     присвоится	значение "True",а если из СБК считается	символ,	порядковый
     номер которого называется расширенным ASCII кодом,	то переменной "Fl"
     присвоится	значение"False"	}
	 Code: char;  {	В этой переменной будет	храниться считанное из СБК
     значение: либо порядковый номер символа, либо число ноль }
     begin { Начало программы }
       ClrScr; { Очистим экран дисплея }
       Code:=ReadKey; {	Считаем	наираннее попавшее в СБК данное	}
       { Считанное данное соответствует	случаю с ASCII кодом ? }
       if Code<>#0 then	Fl:=True else		{ Да }
	  begin	Fl:=False; Code:=ReadKey; end;	{ Нет }
       { Распечатаем на	экране результат считывания из СБК }
       write ('Порядковый номер считанного символа равен ');
       writeln (ord(Code));
       writeln ('и ему соответствует символ: ',Code);
       write   ('Порядковый номер этого символа называется ');
       if Fl=True then write ('ASCII кодом')
       else write ('расширенным ASCII кодом');
     end.  { Конец программы }
			       * * * * * * *

		 [6.3] Использования языка "Turbo Pascal"
			 для работы с клавиатурой.
			 =========================
     Примеры работы с клавиатурой, которые мы будем рассматривать в
     этом разделе, интересны тем, что все они управляют	клавиатурой путем
     использования языка "Turbo Pascal"	как такового. Это означает, что	мы
     будем реализовывать наши желания (связанные с клавиатурой)	путем
     использования умения писать программы на языке "Turbo Pascal" и
     знаний того, как происходит ввод данных с клавиатуры.

     Управление	клавиатурой таким способом имеет следующие особенности:
     - позволяет реализовывать некоторые специфические желания:	проверку
       состояния клавиш-переключателей и уничтожение данных в СБК.
     - недостаток этого	метода состоит в том, что он дает нам ограниченные
       возможности по управлению клавиатурой.

	     [6.3.1] Проверка состояния	клавиш-переключателей
	     (с	помощью	данных в ОЗУ по	адресам	417h и 418h).
	     ------------------------------------------------
     Этот пример показывает, каким образом можно проверить состояния
     клавиш-переключателей. Когда может	пригодится этот	пример ?
     Например тогда, когда Вашей программе захочется узнать: включен ли
     режим ввода символов в прописном виде, как	используются клавиши
     дополнительной клавиатуры (как клавиши управления курсора или как
     символьные	клавиши) и т.д.	Дело ведь еще и	в том, что в СБК
     не	заносятся к-либо символы при нажатии и отпускании клавиш
     - переключателей. Приятное	исключение - это клавиша "Ins(ert)".
     Хотя она и	клавиша-переключатель, но ей ставится в	соответствие
     определенный символ. Почему же данные о нажатиях и	отпусканиях
     клавиш-переключателей не заносятся	в СБК, как обычно, а лишь
     фиксируются в памяти системного блока (по адресам 417h и 418h) ?
     Дело в следующем: представьте себе	что компьютер спрашивает у Вас
     Ваше имя. Вы хотите его ввести, например, имя "TSN". Для того, чтобы
     буквы были	прописные, Вы нажимаете	на клавишу "Shift" и далее, не
     отпуская ее, нажимаете на клавишу с изображением "T". Так вот, если
     бы	клавише-переключателю, в данном	случае клавише "Shift",	ставился
     в соответствие к-либо символ, то Вы ввели бы не только прописную
     букву "T",а к-либо	символ (который	бы соответствовал клавише "Shift")
     и прописную букву "T". Именно потому, что клавиши-переключатели
     используются не для ввода с клавиатуры к-либо символьных данных, а
     лишь для переключения режимов работы клавиатуры (отсюда и их название
     - "переключатели"), данные	о фактах их нажатий и отпусканий не
     заносятся в СБК.
			       - - - - - - -
     { Данная программа	проверяет: находятся ли	клавиши-переключатели,
     которые нас интересуют, в том состоянии, в	каком мы и предполагаем	}
     var Fl:   boolean;	{ Эта переменная будет иметь значение "True",
     если клавиши-переключатели, которыми мы интересуемся, находятся в том
     состоянии,	в каком	мы и предполагаем, иначе присвоим этой переменной
     значение "False" }
	 xData:	word; {	Значение переменной xData определит те
     клавиши-переключатели, о состоянии	которых	мы хотим получить
     информацию. Эта переменная	получается так:

		  xData	  =  Число  + Число + ... + Число

			      Значение Чисел:
      $8000:   клавиша "Insert"	      нажата
      $4000:   клавиша "CapsLock"     нажата
      $2000:   клавиша "NumLock"      нажата
      $1000:   клавиша "ScrollLock"   нажата
       $800:   режим задержки выполнения программы (Ctrl-NumLock) включен
       $400:   клавиша "SysRq"	      нажата
       $200:   клавиша "левая Alt"    нажата
       $100:   клавиша "левая Ctrl"   нажата
	$80:   режим вставки (Insert) включен
	$40:   режим прописных букв (CapsLock) включен
	$20:   режим цифрового использования дополнительной клавиатуры
	       (NumLock) включен
	$10:   режим перемещения окон по экрану	при использования клавиш
	       перемещения (ScrollLock)	включен
	  8:   клавиша "Alt"	      нажата
	  4:   клавиша "Ctrl"	      нажата
	  2:   клавиша "левый Shift"  нажата
	  1:   клавиша "правый Shift" нажата

     Например, если переменная xData=$40+4+2, то это означает, что
     мы	ходим узнать: действительно ли включен режим ввода прописных букв,
     нажата клавиша "Ctrl" и нажата клавиша "левый Shift" ?
     Если это действительно так	(т.е. включен режим ввода прописных букв,
     нажата клавиша "Ctrl" и нажата клавиша "левый Shift" ), то	присвоим
     переменной	Fl значение "True", иначе присвоим переменной Fl значение
     "False" }
     begin { Начало программы }
       { Присвоим переменой xData необходимое значение }
       xData:=$40+4+2;
       { Проверим, соответствует ли состояние клавиш-переключателей
       предполагаемому }
       if MemW[0:$417] and xData = xData then Fl:=True else Fl:=False;
       { Если состояние	клавиш-переключателей соответствует
       предполагаемому,	то сообщить об этом }
       if Fl=True then
	  begin
	    write ('Состояние клавиш-переключателей соответствует ');
	    writeln ('предполагаемому.');
	  end
       else
       { Если состояние	клавиш-переключателей не соответствует
       предполагаемому,	то сообщить об этом }
	  begin
	    write ('Состояние клавиш-переключателей не соответствует ');
	    writeln ('предполагаемому.');
	  end;
     readln;
     end.  { Конец программы }
			       * * * * * * *

			     [6.3.2] Сброс СБК
		 (удаление всех	данных,	хранящихся в СБК).
		 -----------------------------------------
     Этот пример показывает, каким образом Ваша	программа может	уничтожить
     все данные, находящиеся в СБК (т.е. те данные, которые вводились
     с клавиатуры). Когда может	пригодится этот	пример ? Например
     предположим, что Вы написали программу, которая что-то рассчитывает.
     Вот Вы ее запустили на выполнение ... Она начала свой расчет, и
     рассчитывает что-то уже минут 5. В	это время, пока	она рассчитывает,
     Вы	уже немного утомились и	начали баловаться с клавишами (этим Вы как
     бы	пытаетесь ей сказать о Вашем состоянии ...). Вот вы нажали на
     клавишу с изображением "N", вот нажали и на "S" ... Теперь	самое
     интересное: все что Вы нажимаете-попадает в СБК, хотя Ваша	программа
     об	этом и не подозревает. Теперь, минут через 10, Ваша программа
     наконец что-то высчитала и	спрашивает у Вас: "Вы хотите сохранить
     результат расчетов	(Y/N)". И что же Вы думаете будет дальше ? А то,
     что она будет считать, что	те данные, которые хранятся в СБК, и
     есть ответ	на ее запрос. Таким образом, так-как в СБК первым поступил
     символ "N", она посчитает,	что Вы не желаете сохранить результат
     расчетов, а это означает, что все те результаты, которые Вы хотели
     от	нее получить безвозвратно утеряны, и Вам останется лишь	заново
     запустить программу на выполнение и ждать еще 10 минут! Так что Ваше
     баловство с клавишами оказалось роковым ...
	Поэтому-то перед тем, как программе надо что-то	у Вас спросить,
     ей	стоит сбросить все данные в СБК, чтобы кое у кого из нас не
     возникли случайно проблемы.
			       - - - - - - -
     { Данная программа	очищает	СБК, путем занесения в ячейку его "головы"
     содержимого ячейки	его "хвоста" }
     uses crt; { Подключим к этой программе дополнительные возможности:
     очистку экрана, создание пауз и др. }
     begin { Начало программы }
       ClrScr; { Очистим экран дисплея }
       writeln ('Понажимайте на к-либо клавиши ...');
       delay (3000); { Сделаем паузу в 3с (чтобы можно было успеть нажать
       на к-либо клавиши), перед тем как сделать сброс СБК }
       MemW[0:$41C]:=MemW[0:$41A]; { Эта команда сбрасывает СБК	}
       writeln ('Все введенные Вами с клавиатуры данные уничтожены.');
     end.  { Конец программы }

			       * * * * * * *

		 [6.4] Использования языка "Turbo Pascal"
	  и специальной	программы BIOS для работы с клавиатурой.
	  ======================================================
     Примеры работы с клавиатурой, которые мы будем рассматривать в
     этом разделе, интересны тем, что все они управляют	клавиатурой путем
     использования специальной программы BIOSа (эта программа находится
     постоянно в памяти	системного блока даже при отключении питания
     компьютера). Мы будем сообщать этой программе наши	желания	(т.е. то,
     что нам нужно от клавиатуры), а она будет за нас их реализовывать
     (т.е. она сама будет объяснять клавиатуре все, что	нам от нее нужно).
     Каким же образом наша программа будет "общаться" с	программой BIOSа ?
     Ответ таков: наша программа будет "общаться" с программой BIOSа путем
     использования (вызова) прерывания №16h.

     Надо заметить, что	используя эту специальную программу BIOSа (которая
     служит для	выполнения прерывания №16h) наши программы работают не с
     клавиатурой, а с данными СБК. Что значит "работают не с клавиатурой,
     а с данными СБК" смотрите в [6.1]. В таблице [5.1] Вы можете
     посмотреть	порядковые номера всех символов, которые имеются в
     компьютере, а в таблице [5.2] приведены данные, которые записываются
     в ячейки СБК после	нажатия	на клавиши клавиатуры.

     Управление	клавиатурой таким способом имеет следующие особенности:
     - просто выполняются наши желания по вводу	с клавиатуры символов
       (если говорить точнее, то символы вводится не с клавиатуры, а с
       СБК), причем нам	нет необходимости знать	к-либо тонкости	работы
       клавиатуры, а также то, каким образом данные с клавиатуры поступают
       в нашу программу;
     - недостаток этого	метода состоит в том, что он дает нам не все
       возможности (из существующих) по	управлению клавиатурой.

	       [6.4.1] Считывание скэн-кода и ASCII кода символа
		    или	расширенного ASCII кода	из СБК.
		    -----------------------------------
     Этот пример делает	все то же самое, что и пример [6.2.2], т.е.
     позволяет считывать из СБК	к-либо данное: букву, цифру и т.д.
     Единственное отличие этого	примера	от примера [6.2.2] в том, что он
     позволяет считывать с СБК не только порядковый номер соответствующего
     нажатой клавиши символа (это для случая, когда порядковому	номеру
     дано название "ASCII код"), но и скэн-код самой
     клавиши.
			       - - - - - - -
     { Данная программа	считывает из СБК наираннее поступившую туда
     информацию: либо скэн-код нажатой клавиши и ASCII код символа, либо
     расширенный ASCII код символа и число 0 }
     { ----------------------------------------------------------------- }
     { Подключим к этой	программе дополнительные возможности: очистку
     экрана, создание пауз и др. }
     uses crt,
     { Подключим к этой	программе дополнительные возможности: вызов
     прерываний	и др. }
	  dos;
     { Определим переменную,которая будет использоваться в этой	программе}
     var a: registers; { Эта переменная	будет "общаться" с прерыванием
     №16h. Перед вызовом этого прерывания мы подготовим	в переменной "a"
     информацию, которая сообщит прерыванию №16h о нашем желании узнать	от
     него наираннее поступившую	в СБК информацию о вводе данных	с
     клавиатуры. После выполнения этого	прерывания оно поместит	в
     переменную	"a" ту информацию из СБК, которую мы и желали от него
     узнать }
     { Начало программы	}
     begin
     { Очистим экран и выведем на него надпись }
     ClrScr; writeln;
     writeln ('У Вас в распоряжении 3 секунд. Нажимайте на клавиши ...');
     delay (3000); { Сделаем паузу в 3 секунды,	в течении которой
     необходимо	нажимать на символьные клавиши.	Информация о фактах
     нажатия и отпускания клавиш будет помещена	специальной программой
     BIOSа, выполняющей	прерывание №9, в СБК, из которого мы и будем
     после паузы считывать данные с помощью прерывания №16h }
     { Вызовем прерывание №16h }
     a.ah:=$10;	intr($16,a);
     { Выведем на экран	информацию, полученную от прерывания №16h }
     writeln ('ASCII код введенного символа равен ',a.al);
     writeln ('Скэн-код нажатой клавиши равен ',a.ah); readln;
     { Конец программы }
     end.
			       * * * * * * *

		 [6.4.2] Запись	в конец	СБК своих данных.
		 ----------------------------------------
     Этот пример показывает, каким образом можно записать в конец СБК
     свои данные. Когда	может пригодится этот пример ? Например	тогда,
     когда Вашей программе необходимо создать иллюзию нажатия к-либо
     клавиши на	клавиатуре. Кому может пригодится этот трюк ? Например
     очень умной программе, которой Вы отвечаете на к-либо ее вопрос.
     Если, к примеру, Вы введете слово "Компьютерр", то	такая программа
     сразу додуматься, что Вы нечаянно ввели лишнюю букву "р", и поэтому
     она сразу же за Вас аккуратно "нажмет" на клавишу "BackSpace" (эта
     клавиша стирает символ левее курсора), путем записи в конец СБК
     данных, соответствующих клавише "BackSpace".
			       - - - - - - -
     { Данная программа	записывает в конец конец СБК те	данные,	которые
     мы	хотим туда записать }
     { Подключим к этой	программе дополнительные возможности:
     вызов прерываний и	др. }
     uses dos;
     { Определим переменную, которая будет использоваться в этой
     программе }
     var a: registers; { Эта переменная	будет "общаться" с прерыванием
     №16h. Перед вызовом этого прерывания мы подготовим	в переменной "a"
     информацию, которая сообщит прерыванию №16h о нашем желании записать
     в конец СБК наши данные. После выполнения этого прерывания	оно
     запишет в конец СБК наши данные }
     { Начало программы	}
     begin
     { Подготовим в переменной "a" информацию, которая сообщит прерыванию
     №16h о нашем желании записать в конец СБК наши данные }
     a.cl:=197;	{ Определим порядковый номер того символа,который мы хотим
		  поместить в конец СБК	(поместим, например, в конец СБК
		  символ "┼", его порядковый номер равен 197) }
     a.ch:=00;	{ Определим скэн-код, соответствующий данному символу
		  (пусть скэн-код, соответствующий символу "┼" будет
		  равен,например, 00) }
     { Вызовем прерывание №16h }
     a.ah:=$05;	intr($16,a);
     { Узнаем у	прерывания №16h, успешно ли прошла запись наших	данных
     в СБК }
     if	a.al=0 then writeln ('Данные в СБК записаны успешно.')	else
     writeln ('Данные в СБК не записаны, т.к. СБК весь полон!'); readln;
     { Конец программы }
     end.
			       * * * * * * *

		 [6.5] Использования языка "Turbo Pascal"
	      и	портов ввода/вывода для	работы с клавиатурой.
	     ===============================================
     Примеры работы с клавиатурой, которые мы будем рассматривать в
     этом разделе, интересны тем, что все они управляют	клавиатурой путем
     посылки определенных приказов прямо в контроллер клавиатуры.

     Управление	клавиатурой таким способом имеет следующие особенности:
     - очень быстро получаем от	клавиатуры желаемый результат;
     - имеем возможность заставить клавиатуру делать все необычные
       вещи (например: мигать индикаторами клавиатуры, не реагировать на
       любые факты нажатий и отпусканий	клавиш и т.д.);
     - недостатком этого метода	можно считать то, что необходимо знать
       как именно нужно	реализовывать наше желание, необходимо знать
       особенности клавиатуры. Но не стоит этого пугаться, мы с	Вами ...

		      [6.5.1] Отключение клавиатуры.
		      ------------------------------
     Этот пример показывает, каким образом можно запретить клавиатуре
     воспринимать любые	факты нажатий и	отпусканий клавиш. Когда может
     понадобиться отключить клавиатуру ? Например тогда, когда Вашей
     программе необходимо делать какие-то расчеты. Дело	в том, что когда
     клавиатура	работает нормально, любое нажатие на клавиатуре	будет
     отвлекать системный блок (он будет	вынужден выполнять прерывание №9).
     Поэтому чтобы ускорить работу программы, можно отключить клавиатуру,
     чтобы она не мешала работе	системного блока (т.к. именно он выполняет
     программу). А когда она понадобится, ее будет нужно снова включить.
			       - - - - - - -
     { Данная программа	запрещает контроллеру клавиатуры воспринимать
     факты нажатий и отжатий клавиш. В отключенном состоянии данные
     о фактах нажатий и	отжатий	клавиш нигде не	накапливаются и	узнать о
     их	существовании невозможно. Кроме	отключения клавиатуры данная
     команда устанавливает стандартные скорость	автоповтора символов и
     начальную задержку	перед включением автоповтора }
     uses crt; { Подключим к этой программе дополнительные возможности:
     создание пауз и др. }
     begin { Начало программы }
       ClrScr; { Очистим экран дисплея }
       Port[$60]:=$f5; { Пошлем	контроллеру клавиатуры команду,	которая
       запретит	ему воспринимать факты нажатий и отпусканий клавиш }
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланную ему команду }
       writeln ('Понажимайте на клавиши...');
       delay (5000); { Сделаем паузу в 5с. Данные о фактах нажатий и
       отпусканий клавиш, которые будут	сейчас поступать с клавиатуры,
       не будут	восприниматься клавиатурой }
       Port[$60]:=$f4; { Включим клавиатуру. Все данные	о фактах нажатий
       и отпусканий клавиш были	утеряны, и узнать о них	невозможно }
     end.  { Конец программы }
			       * * * * * * *

		       [6.5.2] Включение клавиатуры.
		       -----------------------------
     Этот пример показывает, каким образом можно включить клавиатуру.
			       - - - - - - -
     { Данная программа	разрешает контроллеру клавиатуры воспринимать
     факты нажатий и отжатий клавиш. В отключенном состоянии данные
     о фактах нажатий и	отпусканий клавиш нигде	не накапливаются и
     узнать о их существовании невозможно }
     uses crt; { Подключим к этой программе дополнительные возможности:
     создание пауз и др. }
     begin { Начало программы }
       Port[$60]:=$f4; { Пошлем	контроллеру клавиатуры команду,	которая
       разрешит	ему воспринимать факты нажатий и отпусканий клавиш }
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланную ему команду }
     end.  { Конец программы }
			       * * * * * * *

		      [6.5.3] Блокировка клавиатуры.
		      ------------------------------
     Этот пример показывает, каким образом можно запретить клавиатуре
     посылать запросы на прерывание №9 в системный блок. Когда может
     понадобиться заблокировать	клавиатуру ? Например тогда, когда Вашей
     программе необходимо делать какие-то расчеты. Дело	в том, что когда
     клавиатура	работает нормально, любое нажатие на клавиатуре	будет
     отвлекать системный блок (он будет	вынужден выполнять прерывание №9).
     Поэтому чтобы ускорить работу программы (а	ее выполняет системный
     блок), можно отключить клавиатуру,	чтобы она не мешала работе
     системного	блока. А когда она понадобится,	то ее можно снова
     включить. Отличие блокировки клавиатуры от	ее выключения состоит в
     том, что при блокировке данные о фактах нажатий и отпусканий клавиш
     накапливаются в буфере клавиатуры (до тех пор, пока он весь не
     заполнится) и после разблокировки они оттуда поступают в системный
     блок, а при отключении клавиатуры все данные о фактах нажатий и
     отпусканий	клавиш нигде не	накапливаются и	узнать что-либо	о них
     совершенно	невозможно.
			       - - - - - - -
     { Данная программа	запрещает контроллеру клавиатуры посылать запросы
     на	прерывание №9 в	системный блок.	В заблокированном состоянии
     данные о фактах нажатий и отпусканий клавиш накапливаются в буфере
     клавиатуры	и могут	поступить оттуда в системный блок только после
     разблокировки клавиатуры }
     uses crt; { Подключим к этой программе дополнительные возможности:
     создание пауз и др. }
     begin { Начало программы }
       ClrScr; { Очистим экран дисплея }
       Port[$64]:=$ad; { Пошлем	контроллеру клавиатуры команду,
       запрещающую ему запрашивать прерывание №9 у системного блока }
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланную ему команду }
       writeln ('Понажимайте на клавиши...');
       delay (5000); { Сделаем паузу в 5с. Данные о фактах нажатий и
       отпусканий клавиш, которые будут	сейчас поступать с клавиатуры,
       будут накапливаться в буфере клавиатуры }
       Port[$64]:=$ae; { Разблокируем клавиатуру. Теперь все данные о
       фактах нажатий и	отпусканий клавиш будут	переданы системному
       блоку, (после чего мы можем их считать с	системного буфера
       клавиатуры) }
       readln; { Распечатаем на	экране содержимое СБК }
     end.  { Конец программы }
			       * * * * * * *

		     [6.5.4] Разблокировка клавиатуры.
		     ---------------------------------
     Этот пример показывает, каким образом можно разблокировать
     клавиатуру.
			       - - - - - - -
     { Данная программа	разрешает контроллеру клавиатуры посылать запросы
     на	прерывание №9 в	системный блок.	В заблокированном состоянии
     данные о фактах нажатий и отпусканий клавиш накапливаются в буфере
     клавиатуры	и могут	поступить оттуда в системный блок только после
     разблокировки клавиатуры }
     uses crt; { Подключим к этой программе дополнительные возможности:
     создание пауз и др. }
     begin { Начало программы }
       Port[$64]:=$ae; { Пошлем	контроллеру клавиатуры команду,
       разрешающую запрашивать прерывание №9 у системного блока	}
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланную ему команду }
     end.  { Конец программы }
			       * * * * * * *

	    [6.5.5] Установка стандартных скорости автоповтора
	символов и начальной задержки перед включением автоповтора.
	-----------------------------------------------------------
     Этот пример показывает, каким образом можно установить стандартные
     (принятые по умолчанию) скорость автоповтора символов и начальную
     задержку перед включением автоповтора. Надо отметить, что стандартная
     установка устанавливает такие значения параметров автоповтора,которые
     не	очень удобны при быстрой работе	с текстом (в таких случаях курсор,
     например, еле-еле перемещается по экрану).	Поэтому	данный пример
     используется в тех	случаях, когда требуется не очень быстрая или
     ответственная работа с клавиатурой, например при вводе к-либо важных
     документов.
			       - - - - - - -
     { Данная программа	приказывает контроллеру	клавиатуры установить
     стандартные (принятые по умолчанию) скорость автоповтора символов
     и начальную задержку перед	включением автоповтора }
     uses crt; { Подключим к этой программе дополнительные возможности:
     создание пауз и др. }
     begin { Начало программы }
       Port[$60]:=$f6; { Пошлем	контроллеру клавиатуры команду,
       заставляющую его	установить стандартную скорость	автоповтора
       символов	и начальную задержку перед включением автоповтора }
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланную ему команду }
     end.  { Конец программы }
			       * * * * * * *

	      [6.5.6] Установка	скорости автоповтора символов
		 и задержки перед включением автоповтора.
		 ----------------------------------------
     Этот пример показывает, каким образом можно установить свою
     (желаемую)	скорость автоповтора символов и	начальную задержку перед
     включением	автоповтора. Когда есть	необходимость делать собственную
     установку параметров автоповтора ?	Такая установка	необходима
     например в	игровых	программах. Игровые программы, как правило,
     устанавливают самую маленькую задержку перед включением автоповтора
     и самую большую скорость повтора символов.	И что же это им	дает ?
     А то, что нажав, например,	на клавишу "стрелка вправо", в компьютер
     за	1 секунду поступит не 5	или 10 данных о	клавише	"стрелка вправо",
     а несколько десятков (20 или даже 30). Поэтому игровая программа,
     подумав, что клавишу "стрелка вправо" действительно нажимали раз 30,
     передвинет	к-либо человечка на экране на значительное расстояние. А
     если бы параметры автоповтора были	стандартными (обычными), то
     нажатие на	туже же	самую клавишу "стрелка вправо" в течении той же
     секунды вызвало бы	гораздо	меньшее	поступление в компьютер	данных о
     нажатии клавиши "стрелка вправо", и игровая программа, подумав,
     что клавишу "стрелка вправо" нажимали всего разов 5, передвинула бы
     человечка на гораздо меньшее расстояние, и	игра была бы крайне
     медленной и играть	в нее было бы не интересно.
			       - - - - - - -
     { Данная программа	приказывает контроллеру	клавиатуры установить
     нужную нам	скорость автоповтора символов и	задержку перед включением
     автоповтора символов }
     uses crt; { Подключим к этой программе дополнительные возможности:
     создание пауз и др. }
     var xData:	byte;
     { Значение	переменной xData определит желаемую нами скорость
     автоповтора символов и задержку перед включением автоповтора
     символов. Эта переменная рассчитывается так:
	 xData	 =     Скорость(с/сек) + Задержка(мс)
			    ║		   ║
			    0:	30.0	   0:	250
			    1:	26.7	   32:	500
			    2:	24.0	   64:	750
			    4:	20.0	   96:	1000
			    8:	15.0
			   10:	10.0
			   13:	9.2
			   16:	7.5
			   20:	5.0
			   31:	2.0
     Например, если переменная xData=4+32, то это означает, что
     мы	ходим установим	скорость автоповтора, равную 20	символов в
     секунду, и	время задержки перед включением	автоповтора, равное 0.5
     секунды }
     begin { Начало программы }
       Port[$60]:=$f3; { Пошлем	контроллеру клавиатуры команду,
       заставляющую его	установить нужную нам скорость автоповтора
       символов	и задержку перед включением автоповтора	}
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланную ему команду }
       xData:=4+32; { Пошлем контроллеру клавиатуры данное, которое
       определит желаемую нами скорость	автоповтора символов и задержку
       перед включением	автоповтора. В данном случае мы	установим скорость
       автоповтора, равную 20 символов в секунду, и время задержки
       автоповтора, равное 0.5 секунды }
       Port[$60]:=xData;
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланное ему данное }
     end.  { Конец программы }
			       * * * * * * *

	   [6.5.7] Включение/выключение	индикаторов клавиатуры.
	   ----------------------------------------------------
     Этот пример показывает, каким образом можно включать и выключать
     индикаторы	клавиатуры. Вообще-то включением и выключением
     индикаторов клавиатуры занимается специальная программа BIOSа,
     которая обрабатывает прерывание №9	(это прерывание	запрашивает
     клавиатура), и она	сама знает, в какое время какие	индикаторы должны
     светиться,	а какие	нет. Но	иногда нам бывает необходимо
     самостоятельно "помучить" индикаторы клавиатуры, путем их включения
     или выключения, например когда мы решим устроить из индикаторов
     клавиатуры	цветомузыку ...
			       - - - - - - -
     { Данная программа	приказывает контроллеру	клавиатуры включить или
     выключить те индикаторы клавиатуры, которые мы хотим }
     uses crt; { Подключим к этой программе дополнительные возможности:
     создание пауз и др. }
     var xData:	byte;
     { Значение	переменной xData определит, какие индикаторы нам
     необходимо	включить, а какие выключить. Эта переменная определяется
     так:
	 xData	 =     2: включить  +  4: включить  +  1: включить
		       0: выключить    0: выключить    0: выключить
		       "NumLock"       "CapsLock"      "ScrollLock"
		       индикатор       индикатор       индикатор
     Например, если переменная xData=0+4+0, то это означает, что мы хотим
     включить индикатор	клавиатуры "CapsLock" }
     begin { Начало программы }
       Port[$60]:=$ed; { Пошлем	контроллеру клавиатуры команду,
       заставляющую его	включить или выключить нужные нам индикаторы
       клавиатуры }
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланную ему команду }
       xData:=4; { Пошлем контроллеру  клавиатуры данное, которое
       определит, какие	индикаторы клавиатуры нам необходимо включить,
       а какие выключить. В данном случае мы включим индикатор клавиатуры
       "CapsLock" }
       Port[$60]:=xData;
       delay (30); { Сделаем паузу в 30мс, чтобы контроллер клавиатуры
       смог "переварить" посланное ему данное }
     end.  { Конец программы }
			       * * * * * * *

			       [7] ЗАДАНИЯ.
			       ************
      Примечание: цифра	перед условием программы есть номер варианта.
			       - - - - - - -

       Используя стандартные возможности языка "Turbo Pascal" для работы
		с клавиатурой написать программу, которая:
		==========================================
     1)	Запрашивает с клавиатуры 5 различных строк символов и печатает
	каждую из них на экране	по 3 раза.
			       - - - - - - -
     Используя расширенные возможности языка "Turbo Pascal" для	работы
		с клавиатурой написать программу, которая:
		==========================================
     2)	Проверяет наличие данных в системном буфере клавиатуры и если они
	там есть, то сбрасывает	СБК.
     3)	Проверяет наличие данных в системном буфере клавиатуры и если они
	там есть, то считывает их оттуда и распечатывает их на экране.
     4)	Проверяет наличие данных в системном буфере клавиатуры и если они
	там есть, то считывает 10 данных (ячеек) из СБК.
     5)	Проверяет наличие данных в системном буфере клавиатуры и если они
	там есть, то считывает их оттуда, печатая при этом на экране лишь
	те из считанных	данных,	которые	имеют расширенный ASCII	код.
     6)	Проверяет наличие данных в системном буфере клавиатуры и если они
	там есть, то считывает их оттуда, печатая при этом на экране лишь
	те из считанных	данных,	которые	имеют ASCII код.
     7)	Считывает данные из СБК	до тех пор, пока не считает данное,
	соответствующее	клавише	"F1".
     8)	Считывает данные из СБК	до тех пор, пока не считает данное,
	соответствующее	клавише	"Enter".
			       - - - - - - -
	   Используя возможности языка "Turbo Pascal" для работы
		с клавиатурой написать программу, которая:
		==========================================
     9)	 Проверяет: включен или	выключен режим прописных букв (CapsLock).
	 Результат проверки печатает на	экране.
     10) Проверяет: включен или	выключен режим цифрового использования
	 дополнительной	клавиатуры. Результат проверки печатает	на экране.
     11) Считывает состояние клавиши-переключателя "Ctrl" до тех пор, пока
	 она не	будет нажата.
     12) Считывает состояние клавиши-переключателя "левая Alt" до тех пор,
	 пока она не будет нажата.
     13) Запрашивать с клавиатуры символы до тех пор, пока не нажмут на
	 клавишу "правый Shift".
			       - - - - - - -
	  Используя язык "Turbo Pascal"	и специальную программу
	BIOS для работы	с клавиатурой написать программу, которая:
	==========================================================
     14) Считывает данные из СБК до тех	пор, пока не считает данное,
	 соответствующее клавиши дополнительной	клавиатуры с изображением
	 "*".
     15) Считывает данные из СБК до тех	пор, пока не считает данное,
	 соответствующее клавиши дополнительной	клавиатуры с изображением
	 "+".
     16) Считывает данные из СБК до тех	пор, пока не считает данное,
	 соответствующее одновременному	нажатию	клавиш "Ctrl" и	"F12".
     17) Считывает данные из СБК до тех	пор, пока не считает данное,
	 соответствующее одновременному	нажатию	клавиш "Shift" и "F5".
     18) Записывает в конец СБК	данное,	соответствующее	клавише	с
	 изображением "R".
     19) Записывает в конец СБК	данное,	соответствующее	клавише	"Space".
			       - - - - - - -
       Используя язык "Turbo Pascal" и порты ввода/вывода для работы
		с клавиатурой написать программу, которая:
		==========================================
     20) Отключает клавиатуру на 5 секунд, после чего ее включает.
     21) Блокирует клавиатуру на 3 секунд, после чего ее разблокирует.
     22) Устанавливает стандартные скорость автоповтора	символов и
	 начальную задержку перед включением автоповтора, если в СБК нет
	 данных.
     23) Устанавливает стандартные скорость автоповтора	символов и
	 начальную задержку перед включением автоповтора, если в СБК есть
	 данные.
     24) Устанавливает скорость	автоповтора символов, равную 15	символов в
	 секунду и начальную задержку перед включением автоповтора, равную
	 0.5 секунды.
     25) Устанавливает скорость	автоповтора символов, равную 30	символов в
	 секунду и начальную задержку перед включением автоповтора, равную
	 250 мс.
     26) Включает на 2 секунды индикатор "NumLock", после чего выключает
	 его.
     27) Включает на 4 секунды индикаторы "CapsLock" и "ScrollLock", после
	 чего выключает	их.
     28) Включает и выключает поперемено в течении 5 секунд индикаторы
	 "NumLock" и "ScrollLock".
     29) Включает и выключает поперемено все индикаторы	клавиатуры в
	 течении 7 секунд.
     30) Включает и выключает все индикаторы клавиатуры	одновременно в
	 течении 3 секунд.
			       * * * * * * *
